<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Android 9.0系统启动流程源码分析“ | 彭启明的技术小屋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Android 9.0系统Activity启动流程分析这几天终于有时间踏实的看一下Activity 启动流程了，梳理总结一下。先发一下整理的这个流程图，然后咱们按照这个路线进一步分析    首先来看看他的入口在哪Launcher 实际上就是手机上的一个应用程序，点击手机上的一个APP icon，实际上就是LauncherActivity 调用startActivity()然后启动你需要的应用程序。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 9.0系统启动流程源码分析“">
<meta property="og:url" content="http://yoursite.com/2019/04/23/9-0系统启动流程源码分析“/index.html">
<meta property="og:site_name" content="彭启明的技术小屋">
<meta property="og:description" content="Android 9.0系统Activity启动流程分析这几天终于有时间踏实的看一下Activity 启动流程了，梳理总结一下。先发一下整理的这个流程图，然后咱们按照这个路线进一步分析    首先来看看他的入口在哪Launcher 实际上就是手机上的一个应用程序，点击手机上的一个APP icon，实际上就是LauncherActivity 调用startActivity()然后启动你需要的应用程序。">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/007e4h7Uly1g2bl06rmrej335s1lun9p.jpg">
<meta property="og:updated_time" content="2019-04-25T01:50:23.997Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 9.0系统启动流程源码分析“">
<meta name="twitter:description" content="Android 9.0系统Activity启动流程分析这几天终于有时间踏实的看一下Activity 启动流程了，梳理总结一下。先发一下整理的这个流程图，然后咱们按照这个路线进一步分析    首先来看看他的入口在哪Launcher 实际上就是手机上的一个应用程序，点击手机上的一个APP icon，实际上就是LauncherActivity 调用startActivity()然后启动你需要的应用程序。">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/007e4h7Uly1g2bl06rmrej335s1lun9p.jpg">
  
    <link rel="alternate" href="/atom.xml" title="彭启明的技术小屋" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">彭启明的技术小屋</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="android 9.0系统启动流程源码分析“
hexo new android-9-0系统启动流程源码分析“" class="article article-type-android 9.0系统启动流程源码分析“
hexo new android" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/23/9-0系统启动流程源码分析“/" class="article-date">
  <time datetime="2019-04-23T07:51:40.000Z" itemprop="datePublished">2019-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android 9.0系统启动流程源码分析“
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-9-0系统Activity启动流程分析"><a href="#Android-9-0系统Activity启动流程分析" class="headerlink" title="Android 9.0系统Activity启动流程分析"></a>Android 9.0系统Activity启动流程分析</h1><p>这几天终于有时间踏实的看一下Activity 启动流程了，梳理总结一下。先发一下整理的这个流程图，然后咱们按照这个路线进一步分析  </p>
<p><img src="http://ww1.sinaimg.cn/large/007e4h7Uly1g2bl06rmrej335s1lun9p.jpg" alt></p>
<p><strong>首先来看看他的入口在哪</strong><br>Launcher 实际上就是手机上的一个应用程序，点击手机上的一个APP icon，实际上就是LauncherActivity 调用startActivity()然后启动你需要的应用程序。所以咱们通过顺着这条路子查找下去。  </p>
<p><strong>Activity</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void startActivity(Intent intent, @Nullable Bundle options) &#123;</span><br><span class="line">        if (options != null) &#123;</span><br><span class="line">            startActivityForResult(intent, -1, options);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Note we want to go through this call for compatibility with</span><br><span class="line">            // applications that may have overridden the method.</span><br><span class="line">            startActivityForResult(intent, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>最终调用的都是startActivityForResult()方法，默认传入的requestCode 是-1 。咱们接下来看一下这个方法<br><strong>startActivityForResult（）</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,</span><br><span class="line">         @Nullable Bundle options) &#123;</span><br><span class="line">     if (mParent == null) &#123;</span><br><span class="line">         options = transferSpringboardActivityOptions(options);</span><br><span class="line">         Instrumentation.ActivityResult ar =</span><br><span class="line">             mInstrumentation.execStartActivity(</span><br><span class="line">                 this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                 intent, requestCode, options);</span><br><span class="line">         if (ar != null) &#123;</span><br><span class="line">             mMainThread.sendActivityResult(</span><br><span class="line">                 mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                 ar.getResultData());</span><br><span class="line">         &#125;</span><br><span class="line">         if (requestCode &gt;= 0) &#123;</span><br><span class="line">             // If this start is requesting a result, we can avoid making</span><br><span class="line">             // the activity visible until the result is received.  Setting</span><br><span class="line">             // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span><br><span class="line">             // activity hidden during this time, to avoid flickering.</span><br><span class="line">             // This can only be done when a result is requested because</span><br><span class="line">             // that guarantees we will get information back when the</span><br><span class="line">             // activity is finished, no matter what happens to it.</span><br><span class="line">             mStartedActivity = true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         cancelInputsAndStartExitTransition(options);</span><br><span class="line">         // TODO Consider clearing/flushing other event sources and events for child windows.</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         if (options != null) &#123;</span><br><span class="line">             mParent.startActivityFromChild(this, intent, requestCode, options);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             // Note we want to go through this method for compatibility with</span><br><span class="line">             // existing applications that may have overridden it.</span><br><span class="line">             mParent.startActivityFromChild(this, intent, requestCode);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>其他代码不用关心，抓重点，调用Instrumentation这个类的execStartActivity（）方法，然后看一下这个类  </p>
<p><strong>Instrumentation-execStartActivity</strong><br>主要方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        int result = ActivityManager.getService()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                    requestCode, 0, null, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ActivityManager.getService() 通过binder 通信获取ActivityManagerService对象引用,在ActivityManagerService 调用startActivity方法，checkStartActivityResult（）方法是用来做校验检测的，比如activity没有在配置文件里注册等。看一下ams里的startActivity方法调用了startActivityAsUser（）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,</span><br><span class="line">        boolean validateIncomingUser) &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line"></span><br><span class="line">    userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), &quot;startActivityAsUser&quot;);</span><br><span class="line"></span><br><span class="line">    // TODO: Switch to user app stacks here.</span><br><span class="line">    return mActivityStartController.obtainStarter(intent, &quot;startActivityAsUser&quot;)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setMayWait(userId)</span><br><span class="line">            .execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityStartController获取 ActivityStarter对象，执行execute方法，看一下这个方法里面的实现吧  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int execute() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // TODO(b/64750076): Look into passing request directly to these methods to allow</span><br><span class="line">        // for transactional diffs and preprocessing.</span><br><span class="line">        if (mRequest.mayWait) &#123;</span><br><span class="line">            return startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class="line">                    mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class="line">                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class="line">                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class="line">                    mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class="line">                    mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class="line">                    mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class="line">                    mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class="line">                    mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class="line">                    mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        onExecutionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上段代码中我们已经看到mayWait是为true 的因为我们设置了setMayWait(userId)，  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ActivityStarter setMayWait(int userId) &#123;</span><br><span class="line">    mRequest.mayWait = true;</span><br><span class="line">    mRequest.userId = userId;</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以应该走startActivityMayWait（）方法，接下来看看这个方法具体调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private int startActivityMayWait(IApplicationThread caller, int callingUid,</span><br><span class="line">           String callingPackage, Intent intent, String resolvedType,</span><br><span class="line">           IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">           IBinder resultTo, String resultWho, int requestCode, int startFlags,</span><br><span class="line">           ProfilerInfo profilerInfo, WaitResult outResult,</span><br><span class="line">           Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity,</span><br><span class="line">           int userId, TaskRecord inTask, String reason,</span><br><span class="line">           boolean allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">       .............</span><br><span class="line">       .......</span><br><span class="line">       ...</span><br><span class="line">       //解析intent数据</span><br><span class="line">       ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,</span><br><span class="line">               0 /* matchFlags */,</span><br><span class="line">                       computeResolveFilterUid(</span><br><span class="line">                               callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">      ...................</span><br><span class="line">      .......</span><br><span class="line">      </span><br><span class="line">       //收集intent数据到ActivityInfo 对象中.</span><br><span class="line">       ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);</span><br><span class="line"></span><br><span class="line">     ..............</span><br><span class="line">     .........</span><br><span class="line">     .....</span><br><span class="line">           //用于记录Activity数据</span><br><span class="line">           final ActivityRecord[] outRecord = new ActivityRecord[1];</span><br><span class="line">           </span><br><span class="line">           int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,</span><br><span class="line">                   voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                   callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,</span><br><span class="line">                   ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,</span><br><span class="line">                   allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line"></span><br><span class="line">          .......</span><br><span class="line">          ...</span><br><span class="line">          ..</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用startActivity方法，查看该方法源码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">        String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">        SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,</span><br><span class="line">        ActivityRecord[] outActivity, TaskRecord inTask, String reason,</span><br><span class="line">        boolean allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line"></span><br><span class="line">    if (TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Need to specify a reason.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mLastStartReason = reason;</span><br><span class="line">    mLastStartActivityTimeMs = System.currentTimeMillis();</span><br><span class="line">    mLastStartActivityRecord[0] = null;</span><br><span class="line"></span><br><span class="line">    mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">            aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">            callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">            options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">            inTask, allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line"></span><br><span class="line">    if (outActivity != null) &#123;</span><br><span class="line">        // mLastStartActivityRecord[0] is set in the call to startActivity above.</span><br><span class="line">        outActivity[0] = mLastStartActivityRecord[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return getExternalResult(mLastStartActivityResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续往下跟进mLastStartActivityResult = startActivity（…)源码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">            SafeActivityOptions options,</span><br><span class="line">            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,</span><br><span class="line">            TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">        int err = ActivityManager.START_SUCCESS;</span><br><span class="line">        // Pull the optional Ephemeral Installer-only bundle out of the options early.</span><br><span class="line">        final Bundle verificationBundle</span><br><span class="line">                = options != null ? options.popAppVerificationBundle() : null;</span><br><span class="line"></span><br><span class="line">        ProcessRecord callerApp = null;</span><br><span class="line">        if (caller != null) &#123;</span><br><span class="line">            callerApp = mService.getRecordForAppLocked(caller);</span><br><span class="line">            if (callerApp != null) &#123;</span><br><span class="line">                callingPid = callerApp.pid;</span><br><span class="line">                callingUid = callerApp.info.uid;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller</span><br><span class="line">                        + &quot; (pid=&quot; + callingPid + &quot;) when starting: &quot;</span><br><span class="line">                        + intent.toString());</span><br><span class="line">                err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int userId = aInfo != null &amp;&amp; aInfo.applicationInfo != null</span><br><span class="line">                ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;</span><br><span class="line"></span><br><span class="line">        if (err == ActivityManager.START_SUCCESS) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;START u&quot; + userId + &quot; &#123;&quot; + intent.toShortString(true, true, true, false)</span><br><span class="line">                    + &quot;&#125; from uid &quot; + callingUid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ActivityRecord sourceRecord = null;</span><br><span class="line">        ActivityRecord resultRecord = null;</span><br><span class="line">        if (resultTo != null) &#123;</span><br><span class="line">            sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);</span><br><span class="line">            if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                    &quot;Will send result to &quot; + resultTo + &quot; &quot; + sourceRecord);</span><br><span class="line">            if (sourceRecord != null) &#123;</span><br><span class="line">                if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">                    resultRecord = sourceRecord;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int launchFlags = intent.getFlags();</span><br><span class="line">        //通过客户端写入Ibinder 信息传入到ams服务获取到ActivityRecord //对象，里有resultWho，requestCode，launchedFromPackage等。</span><br><span class="line">        if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123;</span><br><span class="line">            // Transfer the result target from the source activity to the new</span><br><span class="line">            // one being started, including any failures.</span><br><span class="line">            if (requestCode &gt;= 0) &#123;</span><br><span class="line">                SafeActivityOptions.abort(options);</span><br><span class="line">                return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;</span><br><span class="line">            &#125;</span><br><span class="line">            resultRecord = sourceRecord.resultTo;</span><br><span class="line">            if (resultRecord != null &amp;&amp; !resultRecord.isInStackLocked()) &#123;</span><br><span class="line">                resultRecord = null;</span><br><span class="line">            &#125;</span><br><span class="line">            resultWho = sourceRecord.resultWho;</span><br><span class="line">            requestCode = sourceRecord.requestCode;</span><br><span class="line">            sourceRecord.resultTo = null;</span><br><span class="line">            if (resultRecord != null) &#123;</span><br><span class="line">                resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">            if (sourceRecord.launchedFromUid == callingUid) &#123;</span><br><span class="line">                // The new activity is being launched from the same uid as the previous</span><br><span class="line">                // activity in the flow, and asking to forward its result back to the</span><br><span class="line">                // previous.  In this case the activity is serving as a trampoline between</span><br><span class="line">                // the two, so we also want to update its launchedFromPackage to be the</span><br><span class="line">                // same as the previous activity.  Note that this is safe, since we know</span><br><span class="line">                // these two packages come from the same uid; the caller could just as</span><br><span class="line">                // well have supplied that same package name itself.  This specifially</span><br><span class="line">                // deals with the case of an intent picker/chooser being launched in the app</span><br><span class="line">                // flow to redirect to an activity picked by the user, where we want the final</span><br><span class="line">                // activity to consider it to have been launched by the previous app activity.</span><br><span class="line">                callingPackage = sourceRecord.launchedFromPackage;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) &#123;</span><br><span class="line">            // We couldn&apos;t find a class that can handle the given Intent.</span><br><span class="line">            // That&apos;s the end of that!</span><br><span class="line">            err = ActivityManager.START_INTENT_NOT_RESOLVED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123;</span><br><span class="line">            // We couldn&apos;t find the specific class specified in the Intent.</span><br><span class="line">            // Also the end of the line.</span><br><span class="line">            err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != null</span><br><span class="line">                &amp;&amp; sourceRecord.getTask().voiceSession != null) &#123;</span><br><span class="line">            // If this activity is being launched as part of a voice session, we need</span><br><span class="line">            // to ensure that it is safe to do so.  If the upcoming activity will also</span><br><span class="line">            // be part of the voice session, we can only launch it if it has explicitly</span><br><span class="line">            // said it supports the VOICE category, or it is a part of the calling app.</span><br><span class="line">            if ((launchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == 0</span><br><span class="line">                    &amp;&amp; sourceRecord.info.applicationInfo.uid != aInfo.applicationInfo.uid) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    intent.addCategory(Intent.CATEGORY_VOICE);</span><br><span class="line">                    if (!mService.getPackageManager().activitySupportsIntent(</span><br><span class="line">                            intent.getComponent(), intent, resolvedType)) &#123;</span><br><span class="line">                        Slog.w(TAG,</span><br><span class="line">                                &quot;Activity being started in current voice task does not support voice: &quot;</span><br><span class="line">                                        + intent);</span><br><span class="line">                        err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);</span><br><span class="line">                    err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != null) &#123;</span><br><span class="line">            // If the caller is starting a new voice session, just make sure the target</span><br><span class="line">            // is actually allowing it to run this way.</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!mService.getPackageManager().activitySupportsIntent(intent.getComponent(),</span><br><span class="line">                        intent, resolvedType)) &#123;</span><br><span class="line">                    Slog.w(TAG,</span><br><span class="line">                            &quot;Activity being started in new voice task does not support: &quot;</span><br><span class="line">                                    + intent);</span><br><span class="line">                    err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);</span><br><span class="line">                err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getStack();</span><br><span class="line"></span><br><span class="line">        if (err != START_SUCCESS) &#123;</span><br><span class="line">            if (resultRecord != null) &#123;</span><br><span class="line">                resultStack.sendActivityResultLocked(</span><br><span class="line">                        -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null);</span><br><span class="line">            &#125;</span><br><span class="line">            SafeActivityOptions.abort(options);</span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line">            //权限检测</span><br><span class="line">        boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,</span><br><span class="line">                requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity,</span><br><span class="line">                inTask != null, callerApp, resultRecord, resultStack);</span><br><span class="line">        abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,</span><br><span class="line">                callingPid, resolvedType, aInfo.applicationInfo);</span><br><span class="line">        .............</span><br><span class="line">        ........</span><br><span class="line">        .</span><br><span class="line">        //把将要启动的Activity的相关信息保存在变量r中</span><br><span class="line">        ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">                callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),</span><br><span class="line">                resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null,</span><br><span class="line">                mSupervisor, checkedOptions, sourceRecord);</span><br><span class="line">        if (outActivity != null) &#123;</span><br><span class="line">            outActivity[0] = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     ...........</span><br><span class="line">     .........</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">        return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">                true /* doResume */, checkedOptions, inTask, outActivity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来继续跟进startActivity方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">             IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">             int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">             ActivityRecord[] outActivity) &#123;</span><br><span class="line">     int result = START_CANCELED;</span><br><span class="line">     try &#123;</span><br><span class="line">         mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">         result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                 startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         // If we are not able to proceed, disassociate the activity from the task. Leaving an</span><br><span class="line">         // activity in an incomplete state can lead to issues, such as performing operations</span><br><span class="line">         // without a window container.</span><br><span class="line">         final ActivityStack stack = mStartActivity.getStack();</span><br><span class="line">         if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; stack != null) &#123;</span><br><span class="line">             stack.finishActivityLocked(mStartActivity, RESULT_CANCELED,</span><br><span class="line">                     null /* intentResultData */, &quot;startActivity&quot;, true /* oomAdj */);</span><br><span class="line">         &#125;</span><br><span class="line">         mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     postStartActivityProcessing(r, result, mTargetStack);</span><br><span class="line"></span><br><span class="line">     return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>查找重点代码继续跟进 result = startActivityUnchecked(r….  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// Note: This method should only be called from &#123;@link startActivity&#125;.</span><br><span class="line">   private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">           IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">           int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">           ActivityRecord[] outActivity) &#123;</span><br><span class="line"></span><br><span class="line">       setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">               voiceInteractor);</span><br><span class="line">       //计算启动模式launchMode</span><br><span class="line">       computeLaunchingTaskFlags();</span><br><span class="line">       </span><br><span class="line">       computeSourceStack();</span><br><span class="line"></span><br><span class="line">       mIntent.setFlags(mLaunchFlags);</span><br><span class="line"></span><br><span class="line">       ActivityRecord reusedActivity = getReusableIntentActivity();</span><br><span class="line"></span><br><span class="line">       int preferredWindowingMode = WINDOWING_MODE_UNDEFINED;</span><br><span class="line">       int preferredLaunchDisplayId = DEFAULT_DISPLAY;</span><br><span class="line">       if (mOptions != null) &#123;</span><br><span class="line">           preferredWindowingMode = mOptions.getLaunchWindowingMode();</span><br><span class="line">           preferredLaunchDisplayId = mOptions.getLaunchDisplayId();</span><br><span class="line">       &#125;</span><br><span class="line">      ..............</span><br><span class="line">      ..........</span><br><span class="line">      ....</span><br><span class="line">      </span><br><span class="line">               mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                       mOptions);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else if (mStartActivity != null) &#123;</span><br><span class="line">           mSupervisor.mRecentTasks.add(mStartActivity.getTask());</span><br><span class="line">       &#125;</span><br><span class="line">       mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack);</span><br><span class="line"></span><br><span class="line">       mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(), preferredWindowingMode,</span><br><span class="line">               preferredLaunchDisplayId, mTargetStack);</span><br><span class="line"></span><br><span class="line">       return START_SUCCESS;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 经过处理启动模式，是否添加新栈等一系列操作后最终调用mSupervisor.resumeFocusedStackTopActivityLocke方法<br> 查看 ActivityStackSupervisor里的方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line"></span><br><span class="line">    if (!readyToResume()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    if (r == null || !r.isState(RESUMED)) &#123;</span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(null, null);</span><br><span class="line">    &#125; else if (r.isState(RESUMED)) &#123;</span><br><span class="line">        // Kick off any lingering app transitions form the MoveTaskToFront operation.</span><br><span class="line">        mFocusedStack.executeAppTransition(targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进ActivityStack类里的resumeTopActivityUncheckedLocked方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">       if (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">           // Don&apos;t even start recursing.</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       boolean result = false;</span><br><span class="line">       try &#123;</span><br><span class="line">           // Protect against recursion.</span><br><span class="line">           mStackSupervisor.inResumeTopActivity = true;</span><br><span class="line">           result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">           // When resuming the top activity, it may be necessary to pause the top activity (for</span><br><span class="line">           // example, returning to the lock screen. We suppress the normal pause logic in</span><br><span class="line">           // &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the</span><br><span class="line">           // end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here</span><br><span class="line">           // to ensure any necessary pause logic occurs. In the case where the Activity will be</span><br><span class="line">           // shown regardless of the lock screen, the call to</span><br><span class="line">           // &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped.</span><br><span class="line">           final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);</span><br><span class="line">           if (next == null || !next.canTurnScreenOn()) &#123;</span><br><span class="line">               checkReadyForSleep();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           mStackSupervisor.inResumeTopActivity = false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>查看resumeTopActivityInnerLocked（）方法源码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">        if (!mService.mBooting &amp;&amp; !mService.mBooted) &#123;</span><br><span class="line">            // Not ready yet!</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Find the next top-most activity to resume in this stack that is not finishing and is</span><br><span class="line">        // focusable. If it is not focusable, we will fall into the case below to resume the</span><br><span class="line">        // top activity in the next focusable task.</span><br><span class="line">        final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">        boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false);</span><br><span class="line">        if (mResumedActivity != null) &#123;</span><br><span class="line">            if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                    &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</span><br><span class="line">            pausing |= startPausingLocked(userLeaving, false, next, false);</span><br><span class="line">        &#125;</span><br><span class="line">        if (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class="line">            if (DEBUG_SWITCH || DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                    &quot;resumeTopActivityLocked: Skip resume: need to start pausing&quot;);</span><br><span class="line">            // At this point we want to put the upcoming activity&apos;s process</span><br><span class="line">            // at the top of the LRU list, since we know we will be needing it</span><br><span class="line">            // very soon and it would be a waste to let it get killed if it</span><br><span class="line">            // happens to be sitting towards the end.</span><br><span class="line">            if (next.app != null &amp;&amp; next.app.thread != null) &#123;</span><br><span class="line">                mService.updateLruProcessLocked(next.app, true, null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            if (lastResumed != null) &#123;</span><br><span class="line">                lastResumed.setWillCloseOrEnterPip(true);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">                &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line">            // It is possible for the activity to be resumed when we paused back stacks above if the</span><br><span class="line">            // next activity doesn&apos;t have to wait for pause to complete.</span><br><span class="line">            // So, nothing else to-do except:</span><br><span class="line">            // Make sure we have executed any pending transitions, since there</span><br><span class="line">            // should be nothing left to do at this point.</span><br><span class="line">            executeAppTransition(options);</span><br><span class="line">            if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                    &quot;resumeTopActivityLocked: Top activity resumed (dontWaitForPause) &quot; + next);</span><br><span class="line">            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">                    .......</span><br><span class="line">                    //注释2</span><br><span class="line">                    mStackSupervisor.startSpecificActivityLocked(next, true, false);</span><br><span class="line">                    if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       ......</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从这里的源码可以看到当启动新的activity的时候,上一个activity走完onPause,之后才可以走新activity:onCreate —&gt;onStart—&gt;onResume…<br>接着看注释2:回调过程重新交给ActivityStackSupervisor的startSpecificActivityLocked;  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">            boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">        // Is this activity&apos;s application already running?</span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, true);</span><br><span class="line"></span><br><span class="line">        getLaunchTimeTracker().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">        if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0</span><br><span class="line">                        || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                    // Don&apos;t add this if it is a platform component that is marked</span><br><span class="line">                    // to run in multiple processes, because this is actually</span><br><span class="line">                    // part of the framework so doesn&apos;t make sense to track as a</span><br><span class="line">                    // separate apk in the process.</span><br><span class="line">                    app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,</span><br><span class="line">                            mService.mProcessStats);</span><br><span class="line">                &#125;</span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If a dead object exception was thrown -- fall through to</span><br><span class="line">            // restart the application.</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">                &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>判断当前是否已有进程，如果已经有了就realStartActivityLocked启动Activity,如果没有开启进程。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">          boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">                // Create activity launch transaction.</span><br><span class="line">                .............. </span><br><span class="line">                ............</span><br><span class="line">                ........</span><br><span class="line">                //核心代码重点关注</span><br><span class="line">              final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">                      r.appToken);</span><br><span class="line">              clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),</span><br><span class="line">                      System.identityHashCode(r), r.info,</span><br><span class="line">                      // TODO: Have this take the merged configuration instead of separate global</span><br><span class="line">                      // and override configs.</span><br><span class="line">                      mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                      mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                      r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                      r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">                      profilerInfo));</span><br><span class="line"></span><br><span class="line">              // Set desired final state.</span><br><span class="line">              final ActivityLifecycleItem lifecycleItem;</span><br><span class="line">              if (andResume) &#123;</span><br><span class="line">                  lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">              &#125;</span><br><span class="line">              clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line">             mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          ..............</span><br><span class="line">          ...........</span><br><span class="line">          ......</span><br><span class="line">          .</span><br></pre></td></tr></table></figure>
<p>通过事务进行启动，区别8.0系统源码，8.0直接通过ActivityThread进行启动，9.0通过事务进行启动。ActivityManagerService 获取ClientLifecycleManager对象调用里么的scheduleTransaction方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">    final IApplicationThread client = transaction.getClient();</span><br><span class="line">    transaction.schedule();</span><br><span class="line">    if (!(client instanceof Binder)) &#123;</span><br><span class="line">        // If client is not an instance of Binder - it&apos;s a remote call and at this point it is</span><br><span class="line">        // safe to recycle the object. All objects used for local calls will be recycled after</span><br><span class="line">        // the transaction is executed on client in ActivityThread.</span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上看可以看出来最终调用的是ClientTransaction类的schedule（）方法，那么在看里面的代码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void schedule() throws RemoteException &#123;</span><br><span class="line">     mClient.scheduleTransaction(this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>mClient实际是IApplicationThread，那么谁来实现了这个IApplicationThread了呢？答案就是ActivityThread 里的内部类ApplicationThread  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">       public void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">           ActivityThread.this.scheduleTransaction(transaction);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用的是ActivityThread类里的scheduleTransaction方法，看一下当前类里并没有实现该方法，那他是在哪里调用的，答案就是他的父类，他继承ClientTransactionHandler ，那就看一下他父类是怎么实现的吧。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTransaction(ClientTransaction transaction) &#123;</span><br><span class="line">        transaction.preExecute(this);</span><br><span class="line">        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用用sendMessage这个方法，这个方法在父类是个抽象类，那么看看他的子类如何实现的  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">     if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">         TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">         + &quot;: &quot; + arg1 + &quot; / &quot; + obj);</span><br><span class="line">     Message msg = Message.obtain();</span><br><span class="line">     msg.what = what;</span><br><span class="line">     msg.obj = obj;</span><br><span class="line">     msg.arg1 = arg1;</span><br><span class="line">     msg.arg2 = arg2;</span><br><span class="line">     if (async) &#123;</span><br><span class="line">         msg.setAsynchronous(true);</span><br><span class="line">     &#125;</span><br><span class="line">     mH.sendMessage(msg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>最终是通过handler发送一个消息，那么看看他接受的地方是如何处理的。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case EXECUTE_TRANSACTION:</span><br><span class="line">                   final ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">                   mTransactionExecutor.execute(transaction);</span><br><span class="line">                   if (isSystem()) &#123;</span><br><span class="line">                       // Client transactions inside system process are recycled on the client side</span><br><span class="line">                       // instead of ClientLifecycleManager to avoid being cleared before this</span><br><span class="line">                       // message is handled.</span><br><span class="line">                       transaction.recycle();</span><br><span class="line">                   &#125;</span><br><span class="line">                   // TODO(lifecycler): Recycle locally scheduled transactions.</span><br><span class="line">                   break;</span><br></pre></td></tr></table></figure>
<p>TransactionExecutor 这又是什么鬼，不管了，往下看看他具体实现的时候那么看一下这个类是怎么实现的execute方法呢？  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void execute(ClientTransaction transaction) &#123;</span><br><span class="line">      final IBinder token = transaction.getActivityToken();</span><br><span class="line">      log(&quot;Start resolving transaction for client: &quot; + mTransactionHandler + &quot;, token: &quot; + token);</span><br><span class="line"></span><br><span class="line">      executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">      executeLifecycleState(transaction);</span><br><span class="line">      mPendingActions.clear();</span><br><span class="line">      log(&quot;End resolving transaction&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void executeLifecycleState(ClientTransaction transaction) &#123;</span><br><span class="line">    final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">    if (lifecycleItem == null) &#123;</span><br><span class="line">        // No lifecycle request, return early.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;Resolving lifecycle state: &quot; + lifecycleItem);</span><br><span class="line"></span><br><span class="line">    final IBinder token = transaction.getActivityToken();</span><br><span class="line">    final ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    if (r == null) &#123;</span><br><span class="line">        // Ignore requests for non-existent client records for now.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Cycle to the state right before the final requested state.</span><br><span class="line">    cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */);</span><br><span class="line"></span><br><span class="line">    // Execute the final transition with proper parameters.</span><br><span class="line">    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用executeLifecycleState这个方法里的lifecycleItem.execute，那么lifecycleItem这个类是什么时候传进来的呢，穿越回去看一下这个代码 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">                        r.appToken);</span><br><span class="line">                clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),</span><br><span class="line">                        System.identityHashCode(r), r.info,</span><br><span class="line">                        // TODO: Have this take the merged configuration instead of separate global</span><br><span class="line">                        // and override configs.</span><br><span class="line">                        mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                        mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                        r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">                        profilerInfo));</span><br></pre></td></tr></table></figure>
<p>LaunchActivityItem.obtain(new Intent(r.intent)就是在这里创建的，LaunchActivityItem看一里面的execute源码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void execute(ClientTransactionHandler client, IBinder token,</span><br><span class="line">        PendingTransactionActions pendingActions) &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">    ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client);</span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, null /* customIntent */);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终实现的是ClientTransactionHandler这个类的handleLaunchActivity方法，那么谁实现了这个类呢，答案就是ActivityThread,那么看一下这个方法吧  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public Activity handleLaunchActivity(ActivityClientRecord r,</span><br><span class="line">           PendingTransactionActions pendingActions, Intent customIntent) &#123;</span><br><span class="line">       // If we are getting ready to gc after going to the background, well</span><br><span class="line">       // we are back active so skip it.</span><br><span class="line">       unscheduleGcIdler();</span><br><span class="line">       mSomeActivitiesChanged = true;</span><br><span class="line"></span><br><span class="line">       if (r.profilerInfo != null) &#123;</span><br><span class="line">           mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">           mProfiler.startProfiling();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Make sure we are running with the most recent config.</span><br><span class="line">       handleConfigurationChanged(null, null);</span><br><span class="line"></span><br><span class="line">       if (localLOGV) Slog.v(</span><br><span class="line">           TAG, &quot;Handling launch of &quot; + r);</span><br><span class="line"></span><br><span class="line">       // Initialize before creating the activity</span><br><span class="line">       if (!ThreadedRenderer.sRendererDisabled) &#123;</span><br><span class="line">           GraphicsEnvironment.earlyInitEGL();</span><br><span class="line">       &#125;</span><br><span class="line">       WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">       final Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">       ..................</span><br><span class="line">       ..............</span><br><span class="line">       ........</span><br><span class="line">       .</span><br><span class="line">               </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>重点看一下这个performLaunchActivity这个方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">/**  Core implementation of activity launch. */</span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    if (r.packageInfo == null) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    if (component == null) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.activityInfo.targetActivity != null) &#123;</span><br><span class="line">        component = new ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建上下文</span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = null;</span><br><span class="line">    //注释1</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        if (r.state != null) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //注释2</span><br><span class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);</span><br><span class="line">        if (localLOGV) Slog.v(</span><br><span class="line">                TAG, r + &quot;: app=&quot; + app</span><br><span class="line">                + &quot;, appName=&quot; + app.getPackageName()</span><br><span class="line">                + &quot;, pkg=&quot; + r.packageInfo.getPackageName()</span><br><span class="line">                + &quot;, comp=&quot; + r.intent.getComponent().toShortString()</span><br><span class="line">                + &quot;, dir=&quot; + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = new Configuration(mCompatConfiguration);</span><br><span class="line">            if (r.overrideConfig != null) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</span><br><span class="line">                    + r.activityInfo.name + &quot; with config &quot; + config);</span><br><span class="line">            Window window = null;</span><br><span class="line">            if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = null;</span><br><span class="line">                r.mPendingRemoveWindowManager = null;</span><br><span class="line">            &#125;</span><br><span class="line">            appContext.setOuterContext(activity);</span><br><span class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">            if (customIntent != null) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = null;</span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            activity.mStartedActivity = false;</span><br><span class="line">            int theme = r.activityInfo.getThemeResource();</span><br><span class="line">            if (theme != 0) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = false;</span><br><span class="line">            //注释3</span><br><span class="line">            if (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!activity.mCalled) &#123;</span><br><span class="line">                throw new SuperNotCalledException(</span><br><span class="line">                    &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                    &quot; did not call through to super.onCreate()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">        &#125;</span><br><span class="line">        r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to start activity &quot; + component</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点分析这三个注释，注释1，就很简单了，就是创建了一个Activity对象，注释2就是创建application，看看里么具体的代码吧  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">        Instrumentation instrumentation) &#123;</span><br><span class="line">    if (mApplication != null) &#123;</span><br><span class="line">        return mApplication;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;makeApplication&quot;);</span><br><span class="line"></span><br><span class="line">    Application app = null;</span><br><span class="line"></span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">        appClass = &quot;android.app.Application&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                    &quot;initializeJavaContextClassLoader&quot;);</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate application &quot; + appClass</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActivityThread.mAllApplications.add(app);</span><br><span class="line">    mApplication = app;</span><br><span class="line"></span><br><span class="line">    if (instrumentation != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            instrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Rewrite the R &apos;constants&apos; for all library apks.</span><br><span class="line">    SparseArray&lt;String&gt; packageIdentifiers = getAssets().getAssignedPackageIdentifiers();</span><br><span class="line">    final int N = packageIdentifiers.size();</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        final int id = packageIdentifiers.keyAt(i);</span><br><span class="line">        if (id == 0x01 || id == 0x7f) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前已有application，就直接return，否则创建application，然后重点看这个代码instrumentation.callApplicationOnCreate(app)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void callApplicationOnCreate(Application app) &#123;</span><br><span class="line">     app.onCreate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>呵呵哒，终于看到曙光了，终于看到咱们application里的onCreate 方法了。在回过头看一下注释3是什么鬼东西，同样是 这个类Instrumentation </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">     prePerformCreate(activity);</span><br><span class="line">     activity.performCreate(icicle);</span><br><span class="line">     postPerformCreate(activity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>然后看一下activity.performCreate(icicle)这个方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123;</span><br><span class="line">    mCanEnterPictureInPicture = true;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    if (persistentState != null) &#123;</span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">    &#125;</span><br><span class="line">    writeEventLog(LOG_AM_ON_CREATE_CALLED, &quot;performCreate&quot;);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line"></span><br><span class="line">    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">            com.android.internal.R.styleable.Window_windowNoDisplay, false);</span><br><span class="line">    mFragments.dispatchActivityCreated();</span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>呵呵哒Activity 的onCreate 方法也出来了。这就知道了为什么先执行application oncreate 了吧。那么到这里，Activity 启动就全部讲完了，但是还没有结束，还有断，就是当前进程没有开启的时候，当前点击桌面icon的时候，那个分支还没有讲，那接下来咱们就看一下这个吧，方便大家回忆，我在把之前的代码贴出来看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">            boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">        // Is this activity&apos;s application already running?</span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, true);</span><br><span class="line"></span><br><span class="line">        getLaunchTimeTracker().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">        if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0</span><br><span class="line">                        || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                    // Don&apos;t add this if it is a platform component that is marked</span><br><span class="line">                    // to run in multiple processes, because this is actually</span><br><span class="line">                    // part of the framework so doesn&apos;t make sense to track as a</span><br><span class="line">                    // separate apk in the process.</span><br><span class="line">                    app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,</span><br><span class="line">                            mService.mProcessStats);</span><br><span class="line">                &#125;</span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If a dead object exception was thrown -- fall through to</span><br><span class="line">            // restart the application.</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">                &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>mService.startProcessLocked ，也就是通过ActivityManagerService,咱们继续跟  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line">   final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,</span><br><span class="line">           boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,</span><br><span class="line">           boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,</span><br><span class="line">           String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123;</span><br><span class="line">       long startTime = SystemClock.elapsedRealtime();</span><br><span class="line">       ProcessRecord app;</span><br><span class="line">       if (!isolated) &#123;</span><br><span class="line">           app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line">           checkTime(startTime, &quot;startProcess: after getProcessRecord&quot;);</span><br><span class="line"></span><br><span class="line">           if ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) != 0) &#123;</span><br><span class="line">               // If we are in the background, then check to see if this process</span><br><span class="line">               // is bad.  If so, we will just silently fail.</span><br><span class="line">               if (mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                   if (DEBUG_PROCESSES) Slog.v(TAG, &quot;Bad process: &quot; + info.uid</span><br><span class="line">                           + &quot;/&quot; + info.processName);</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // When the user is explicitly starting a process, then clear its</span><br><span class="line">               // crash count so that we won&apos;t make it bad until they see at</span><br><span class="line">               // least one crash dialog again, and make the process good again</span><br><span class="line">               // if it had been bad.</span><br><span class="line">               if (DEBUG_PROCESSES) Slog.v(TAG, &quot;Clearing bad process: &quot; + info.uid</span><br><span class="line">                       + &quot;/&quot; + info.processName);</span><br><span class="line">               mAppErrors.resetProcessCrashTimeLocked(info);</span><br><span class="line">               if (mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                   EventLog.writeEvent(EventLogTags.AM_PROC_GOOD,</span><br><span class="line">                           UserHandle.getUserId(info.uid), info.uid,</span><br><span class="line">                           info.processName);</span><br><span class="line">                   mAppErrors.clearBadProcessLocked(info);</span><br><span class="line">                   if (app != null) &#123;</span><br><span class="line">                       app.bad = false;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // If this is an isolated process, it can&apos;t re-use an existing process.</span><br><span class="line">           app = null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // We don&apos;t have to do anything more if:</span><br><span class="line">       // (1) There is an existing application record; and</span><br><span class="line">       // (2) The caller doesn&apos;t think it is dead, OR there is no thread</span><br><span class="line">       //     object attached to it so we know it couldn&apos;t have crashed; and</span><br><span class="line">       // (3) There is a pid assigned to it, so it is either starting or</span><br><span class="line">       //     already running.</span><br><span class="line">       if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, &quot;startProcess: name=&quot; + processName</span><br><span class="line">               + &quot; app=&quot; + app + &quot; knownToBeDead=&quot; + knownToBeDead</span><br><span class="line">               + &quot; thread=&quot; + (app != null ? app.thread : null)</span><br><span class="line">               + &quot; pid=&quot; + (app != null ? app.pid : -1));</span><br><span class="line">       if (app != null &amp;&amp; app.pid &gt; 0) &#123;</span><br><span class="line">           if ((!knownToBeDead &amp;&amp; !app.killed) || app.thread == null) &#123;</span><br><span class="line">               // We already have the app running, or are waiting for it to</span><br><span class="line">               // come up (we have a pid but not yet its thread), so keep it.</span><br><span class="line">               if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, &quot;App already running: &quot; + app);</span><br><span class="line">               // If this is a new package in the process, add the package to the list</span><br><span class="line">               app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">               checkTime(startTime, &quot;startProcess: done, added package to proc&quot;);</span><br><span class="line">               return app;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // An application record is attached to a previous process,</span><br><span class="line">           // clean it up now.</span><br><span class="line">           if (DEBUG_PROCESSES || DEBUG_CLEANUP) Slog.v(TAG_PROCESSES, &quot;App died: &quot; + app);</span><br><span class="line">           checkTime(startTime, &quot;startProcess: bad proc running, killing&quot;);</span><br><span class="line">           killProcessGroup(app.uid, app.pid);</span><br><span class="line">           handleAppDiedLocked(app, true, true);</span><br><span class="line">           checkTime(startTime, &quot;startProcess: done killing old proc&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       String hostingNameStr = hostingName != null</span><br><span class="line">               ? hostingName.flattenToShortString() : null;</span><br><span class="line"></span><br><span class="line">       if (app == null) &#123;</span><br><span class="line">           checkTime(startTime, &quot;startProcess: creating new process record&quot;);</span><br><span class="line">           app = newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">           if (app == null) &#123;</span><br><span class="line">               Slog.w(TAG, &quot;Failed making new process record for &quot;</span><br><span class="line">                       + processName + &quot;/&quot; + info.uid + &quot; isolated=&quot; + isolated);</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">           app.crashHandler = crashHandler;</span><br><span class="line">           app.isolatedEntryPoint = entryPoint;</span><br><span class="line">           app.isolatedEntryPointArgs = entryPointArgs;</span><br><span class="line">           checkTime(startTime, &quot;startProcess: done creating new process record&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // If this is a new package in the process, add the package to the list</span><br><span class="line">           app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">           checkTime(startTime, &quot;startProcess: added package to existing proc&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // If the system is not ready yet, then hold off on starting this</span><br><span class="line">       // process until it is.</span><br><span class="line">       if (!mProcessesReady</span><br><span class="line">               &amp;&amp; !isAllowedWhileBooting(info)</span><br><span class="line">               &amp;&amp; !allowWhileBooting) &#123;</span><br><span class="line">           if (!mProcessesOnHold.contains(app)) &#123;</span><br><span class="line">               mProcessesOnHold.add(app);</span><br><span class="line">           &#125;</span><br><span class="line">           if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES,</span><br><span class="line">                   &quot;System not ready, putting on hold: &quot; + app);</span><br><span class="line">           checkTime(startTime, &quot;startProcess: returning with proc on hold&quot;);</span><br><span class="line">           return app;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       checkTime(startTime, &quot;startProcess: stepping in to startProcess&quot;);</span><br><span class="line">       final boolean success = startProcessLocked(app, hostingType, hostingNameStr, abiOverride);</span><br><span class="line">       checkTime(startTime, &quot;startProcess: done starting proc!&quot;);</span><br><span class="line">       return success ? app : null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line"> private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint,</span><br><span class="line">         ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,</span><br><span class="line">         String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span><br><span class="line">         long startTime) &#123;</span><br><span class="line">     app.pendingStart = true;</span><br><span class="line">     app.killedByAm = false;</span><br><span class="line">     app.removed = false;</span><br><span class="line">     app.killed = false;</span><br><span class="line">     final long startSeq = app.startSeq = ++mProcStartSeqCounter;</span><br><span class="line">     app.setStartParams(uid, hostingType, hostingNameStr, seInfo, startTime);</span><br><span class="line">     if (mConstants.FLAG_PROCESS_START_ASYNC) &#123;</span><br><span class="line">         if (DEBUG_PROCESSES) Slog.i(TAG_PROCESSES,</span><br><span class="line">                 &quot;Posting procStart msg for &quot; + app.toShortString());</span><br><span class="line">         mProcStartHandler.post(() -&gt; &#123;</span><br><span class="line">             try &#123;</span><br><span class="line">                 synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                     final String reason = isProcStartValidLocked(app, startSeq);</span><br><span class="line">                     if (reason != null) &#123;</span><br><span class="line">                         Slog.w(TAG_PROCESSES, app + &quot; not valid anymore,&quot;</span><br><span class="line">                                 + &quot; don&apos;t start process, &quot; + reason);</span><br><span class="line">                         app.pendingStart = false;</span><br><span class="line">                         return;</span><br><span class="line">                     &#125;</span><br><span class="line">                     app.usingWrapper = invokeWith != null</span><br><span class="line">                             || SystemProperties.get(&quot;wrap.&quot; + app.processName) != null;</span><br><span class="line">                     mPendingStarts.put(startSeq, app);</span><br><span class="line">                 &#125;</span><br><span class="line">                 final ProcessStartResult startResult = startProcess(app.hostingType, entryPoint,</span><br><span class="line">                         app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo,</span><br><span class="line">                         requiredAbi, instructionSet, invokeWith, app.startTime);</span><br><span class="line">                 synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                     handleProcessStartedLocked(app, startResult, startSeq);</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用startProcess这个方法看看这个方法里面怎么实现  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private ProcessStartResult startProcess(String hostingType, String entryPoint,</span><br><span class="line">        ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,</span><br><span class="line">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span><br><span class="line">        long startTime) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; +</span><br><span class="line">                app.processName);</span><br><span class="line">        checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</span><br><span class="line">        final ProcessStartResult startResult;</span><br><span class="line">        if (hostingType.equals(&quot;webview_service&quot;)) &#123;</span><br><span class="line">            startResult = startWebView(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, null,</span><br><span class="line">                    new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, invokeWith,</span><br><span class="line">                    new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        checkTime(startTime, &quot;startProcess: returned from zygote!&quot;);</span><br><span class="line">        return startResult;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点在这里Process.start（）看一下Process 这个类吧  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static final ProcessStartResult start(final String processClass,</span><br><span class="line">                               final String niceName,</span><br><span class="line">                               int uid, int gid, int[] gids,</span><br><span class="line">                               int runtimeFlags, int mountExternal,</span><br><span class="line">                               int targetSdkVersion,</span><br><span class="line">                               String seInfo,</span><br><span class="line">                               String abi,</span><br><span class="line">                               String instructionSet,</span><br><span class="line">                               String appDataDir,</span><br><span class="line">                               String invokeWith,</span><br><span class="line">                               String[] zygoteArgs) &#123;</span><br><span class="line">     return zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                 runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                 abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>看到zygote就明白了往下就不继续跟了太长了，实际就是通过zygote force一个进程，每个应用程序都是通过zygote force 的进程。进程创建之后那就应该走这个应用程序的Main方法了，别忘了android 是用Java写的，所以入口就是Main（）方法咯。也就是ActivityThread中的Main方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line"></span><br><span class="line">        // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">        // disable it here, but selectively enable it later (via</span><br><span class="line">        // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">        CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        // Set the reporter for event logging in libcore</span><br><span class="line">        EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">        // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span><br><span class="line">        // It will be in the format &quot;seq=114&quot;</span><br><span class="line">        long startSeq = 0;</span><br><span class="line">        if (args != null) &#123;</span><br><span class="line">            for (int i = args.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">                if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                    startSeq = Long.parseLong(</span><br><span class="line">                            args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // End of event ActivityThreadMain.</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在mian方法里创建了looper，还有创建了一个ActivityThread 对象，之前一直以为ActivityThread是主线程，但是看源码发现它并不是一个线程，只是一个对象，其实咱们所的主线程就是整个进程的线程，那么往下看thread.attach(false, startSeq);   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void attach(boolean system, long startSeq) &#123;</span><br><span class="line">        sCurrentActivityThread = this;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        if (!system) &#123;</span><br><span class="line">            ViewRootImpl.addFirstDrawHandler(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    ensureJitEnabled();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,</span><br><span class="line">                                                    UserHandle.myUserId());</span><br><span class="line">            //重点看一下这里注释1</span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            final IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            try &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当前传入的是false 所以重点看一下注释1，注释1主要是通过IBinder获取到AMS，这里就简写了。通过AMS调用attachApplication，咱们重点在看这里  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public final void attachApplication(IApplicationThread thread, long startSeq) &#123;</span><br><span class="line">     synchronized (this) &#123;</span><br><span class="line">         int callingPid = Binder.getCallingPid();</span><br><span class="line">         final int callingUid = Binder.getCallingUid();</span><br><span class="line">         final long origId = Binder.clearCallingIdentity();</span><br><span class="line">         attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">         Binder.restoreCallingIdentity(origId);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在看一下这个方法attachApplicationLocked（）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line">    private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">            int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">                关键代码</span><br><span class="line">                else if (app.instr != null) &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                        app.instr.mClass,</span><br><span class="line">                        profilerInfo, app.instr.mArguments,</span><br><span class="line">                        app.instr.mWatcher,</span><br><span class="line">                        app.instr.mUiAutomationConnection, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers, null, profilerInfo,</span><br><span class="line">                        null, null, null, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>thread.bindApplication这里调用ActivityThread里的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">            List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">            ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">            IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">            IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">            boolean enableBinderTracking, boolean trackAllocation,</span><br><span class="line">            boolean isRestrictedBackupMode, boolean persistent, Configuration config,</span><br><span class="line">            CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span><br><span class="line">            String buildSerial, boolean autofillCompatibilityEnabled) &#123;</span><br><span class="line"></span><br><span class="line">        if (services != null) &#123;</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                // Test code to make sure the app could see the passed-in services.</span><br><span class="line">                for (Object oname : services.keySet()) &#123;</span><br><span class="line">                    if (services.get(oname) == null) &#123;</span><br><span class="line">                        continue; // AM just passed in a null service.</span><br><span class="line">                    &#125;</span><br><span class="line">                    String name = (String) oname;</span><br><span class="line"></span><br><span class="line">                    // See b/79378449 about the following exemption.</span><br><span class="line">                    switch (name) &#123;</span><br><span class="line">                        case &quot;package&quot;:</span><br><span class="line">                        case Context.WINDOW_SERVICE:</span><br><span class="line">                            continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (ServiceManager.getService(name) == null) &#123;</span><br><span class="line">                        Log.wtf(TAG, &quot;Service &quot; + name + &quot; should be accessible by this app&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Setup the service cache in the ServiceManager</span><br><span class="line">            ServiceManager.initServiceCache(services);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">        AppBindData data = new AppBindData();</span><br><span class="line">        data.processName = processName;</span><br><span class="line">        data.appInfo = appInfo;</span><br><span class="line">        data.providers = providers;</span><br><span class="line">        data.instrumentationName = instrumentationName;</span><br><span class="line">        data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">        data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">        data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">        data.debugMode = debugMode;</span><br><span class="line">        data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">        data.trackAllocation = trackAllocation;</span><br><span class="line">        data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">        data.persistent = persistent;</span><br><span class="line">        data.config = config;</span><br><span class="line">        data.compatInfo = compatInfo;</span><br><span class="line">        data.initProfilerInfo = profilerInfo;</span><br><span class="line">        data.buildSerial = buildSerial;</span><br><span class="line">        data.autofillCompatibilityEnabled = autofillCompatibilityEnabled;</span><br><span class="line">        sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看看吧sendMessage是不是很熟悉，咱们看看接收后怎么处理  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case BIND_APPLICATION:</span><br><span class="line">                 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">                 AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                 handleBindApplication(data);</span><br><span class="line">                 Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                 break;</span><br></pre></td></tr></table></figure>
<p>看看这个方法handleBindApplication  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    核心重点代码 </span><br><span class="line"></span><br><span class="line">     final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);</span><br><span class="line">    updateLocaleListFromAppContext(appContext,</span><br><span class="line">            mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Continue loading instrumentation.</span><br><span class="line">    if (ii != null) &#123;</span><br><span class="line">        ApplicationInfo instrApp;</span><br><span class="line">        try &#123;</span><br><span class="line">            instrApp = getPackageManager().getApplicationInfo(ii.packageName, 0,</span><br><span class="line">                    UserHandle.myUserId());</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            instrApp = null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (instrApp == null) &#123;</span><br><span class="line">            instrApp = new ApplicationInfo();</span><br><span class="line">        &#125;</span><br><span class="line">        ii.copyTo(instrApp);</span><br><span class="line">        instrApp.initForUser(UserHandle.myUserId());</span><br><span class="line">        final LoadedApk pi = getPackageInfo(instrApp, data.compatInfo,</span><br><span class="line">                appContext.getClassLoader(), false, true, false);</span><br><span class="line">        final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);</span><br><span class="line">        //注释1 获取mInstrumentation</span><br><span class="line">        try &#123;</span><br><span class="line">            final ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">            mInstrumentation = (Instrumentation)</span><br><span class="line">                cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate instrumentation &quot;</span><br><span class="line">                + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // If the app is being launched for full backup or restore, bring it up in</span><br><span class="line">        // a restricted environment with the base application class.</span><br><span class="line">        app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line"></span><br><span class="line">        // Propagate autofill compat state</span><br><span class="line">        app.setAutofillCompatibilityEnabled(data.autofillCompatibilityEnabled);</span><br><span class="line"></span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        // don&apos;t bring up providers in restricted mode; they may depend on the</span><br><span class="line">        // app&apos;s custom Application class</span><br><span class="line">        if (!data.restrictedBackupMode) &#123;</span><br><span class="line">            if (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">                installContentProviders(app, data.providers);</span><br><span class="line">                // For process that contains content providers, we want to</span><br><span class="line">                // ensure that the JIT is enabled &quot;at some point&quot;.</span><br><span class="line">                mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do this after providers, since instrumentation tests generally start their</span><br><span class="line">        // test thread at this point, and we don&apos;t want that racing.</span><br><span class="line">        try &#123;</span><br><span class="line">            mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Exception thrown in onCreate() of &quot;</span><br><span class="line">                + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                  &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                  + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // If the app targets &lt; O-MR1, or doesn&apos;t change the thread policy</span><br><span class="line">        // during startup, clobber the policy to maintain behavior of b/36951662</span><br><span class="line">        if (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1</span><br><span class="line">                || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> mInstrumentation.callApplicationOnCreate(app);多么熟悉的味道，看吧，最终调用这里，不多说，里面就是application里的oncreate方法了。大家是不是想问，嗯application里的oncreate 方法是走了，那么Activity里的在哪里走，咱们回过头看看attachApplicationLocked这个方法，其实为了方便大家理解重点，后面的方法没贴哈哈，我把后面的重要方法补上你就知道了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line">    private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">            int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">                关键代码</span><br><span class="line">                else if (app.instr != null) &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                        app.instr.mClass,</span><br><span class="line">                        profilerInfo, app.instr.mArguments,</span><br><span class="line">                        app.instr.mWatcher,</span><br><span class="line">                        app.instr.mUiAutomationConnection, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers, null, profilerInfo,</span><br><span class="line">                        null, null, null, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125;</span><br><span class="line">          if (normalMode) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                    didSomething = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>mStackSupervisor.attachApplicationLocked(app)这个是重点，ActivityStackSupervisor 是不是很熟悉咱们在看看  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line">    final String processName = app.processName;</span><br><span class="line">    boolean didSomething = false;</span><br><span class="line">    for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123;</span><br><span class="line">        final ActivityDisplay display = mActivityDisplays.valueAt(displayNdx);</span><br><span class="line">        for (int stackNdx = display.getChildCount() - 1; stackNdx &gt;= 0; --stackNdx) &#123;</span><br><span class="line">            final ActivityStack stack = display.getChildAt(stackNdx);</span><br><span class="line">            if (!isFocusedStack(stack)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.getAllRunningVisibleActivitiesLocked(mTmpActivityList);</span><br><span class="line">            final ActivityRecord top = stack.topRunningActivityLocked();</span><br><span class="line">            final int size = mTmpActivityList.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                final ActivityRecord activity = mTmpActivityList.get(i);</span><br><span class="line">                if (activity.app == null &amp;&amp; app.uid == activity.info.applicationInfo.uid</span><br><span class="line">                        &amp;&amp; processName.equals(activity.processName)) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        if (realStartActivityLocked(activity, app,</span><br><span class="line">                                top == activity /* andResume */, true /* checkConfig */)) &#123;</span><br><span class="line">                            didSomething = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;Exception in new application when starting activity &quot;</span><br><span class="line">                                + top.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">                        throw e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!didSomething) &#123;</span><br><span class="line">        ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);</span><br><span class="line">    &#125;</span><br><span class="line">    return didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>realStartActivityLocked()就是这个方法 ,是不是很熟悉，接下来就走之前已有进程的Activity的启动流程了，这里就不重复说了。  </p>
<h2 id="到此，整个APP如何启动的就已经讲完了，太多了，那里有不足的地方还请大家多多包涵"><a href="#到此，整个APP如何启动的就已经讲完了，太多了，那里有不足的地方还请大家多多包涵" class="headerlink" title="到此，整个APP如何启动的就已经讲完了，太多了，那里有不足的地方还请大家多多包涵"></a><strong>到此，整个APP如何启动的就已经讲完了，太多了，那里有不足的地方还请大家多多包涵</strong></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/23/9-0系统启动流程源码分析“/" data-id="cjuwacu6f0001tpla26j56375" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/04/23/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/23/9-0系统启动流程源码分析“/">Android 9.0系统启动流程源码分析“</a>
          </li>
        
          <li>
            <a href="/2019/04/23/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 pengqiming<br>
      Powered by <a href="https://pqmpqm123.github.io/" target="_blank">PQM</a>
    </div>
  </div>
  <div>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277361153'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s96.cnzz.com/z_stat.php%3Fid%3D1277361153%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>