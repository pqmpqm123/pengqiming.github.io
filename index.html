<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  <title>彭启明的技术小屋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="android">
<meta property="og:type" content="website">
<meta property="og:title" content="彭启明的技术小屋">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="彭启明的技术小屋">
<meta property="og:description" content="android">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="彭启明的技术小屋">
<meta name="twitter:description" content="android">
  
    <link rel="alternate" href="/atom.xml" title="彭启明的技术小屋" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">彭启明的技术小屋</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-LayoutInflate加载详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/30/LayoutInflate加载详解/" class="article-date">
  <time datetime="2019-04-30T02:47:39.000Z" itemprop="datePublished">2019-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/30/LayoutInflate加载详解/">LayoutInflate加载详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们在日常开发中经常会用到LayoutInflate加载布局，添加到自己的View中，那么LayoutInflate类里面是如何去加载出View的呢，咱们一起去探索一下吧。</p>
<p>首先从inflate这个方法入手去看吧  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"> public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">        synchronized (mConstructorArgs) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</span><br><span class="line"></span><br><span class="line">            final Context inflaterContext = mContext;</span><br><span class="line">            final AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">            Context lastContext = (Context) mConstructorArgs[0];</span><br><span class="line">            mConstructorArgs[0] = inflaterContext;</span><br><span class="line">            View result = root;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                // Look for the root node.</span><br><span class="line">                int type;</span><br><span class="line">                while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                        type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                    // Empty</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                    throw new InflateException(parser.getPositionDescription()</span><br><span class="line">                            + &quot;: No start tag found!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final String name = parser.getName();</span><br><span class="line"></span><br><span class="line">                if (DEBUG) &#123;</span><br><span class="line">                    System.out.println(&quot;**************************&quot;);</span><br><span class="line">                    System.out.println(&quot;Creating root view: &quot;</span><br><span class="line">                            + name);</span><br><span class="line">                    System.out.println(&quot;**************************&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                    if (root == null || !attachToRoot) &#123;</span><br><span class="line">                        throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</span><br><span class="line">                                + &quot;ViewGroup root and attachToRoot=true&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Temp is the root view that was found in the xml</span><br><span class="line">                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                    ViewGroup.LayoutParams params = null;</span><br><span class="line"></span><br><span class="line">                    if (root != null) &#123;</span><br><span class="line">                        if (DEBUG) &#123;</span><br><span class="line">                            System.out.println(&quot;Creating params from root: &quot; +</span><br><span class="line">                                    root);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // Create layout params that match root, if supplied</span><br><span class="line">                        params = root.generateLayoutParams(attrs);</span><br><span class="line">                        if (!attachToRoot) &#123;</span><br><span class="line">                            // Set the layout params for temp if we are not</span><br><span class="line">                            // attaching. (If we are, we use addView, below)</span><br><span class="line">                            temp.setLayoutParams(params);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        System.out.println(&quot;-----&gt; start inflating children&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Inflate all children under temp against its context.</span><br><span class="line">                    rInflateChildren(parser, temp, attrs, true);</span><br><span class="line"></span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        System.out.println(&quot;-----&gt; done inflating children&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // We are supposed to attach all the views we found (int temp)</span><br><span class="line">                    // to root. Do that now.</span><br><span class="line">                    if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                        root.addView(temp, params);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Decide whether to return the root that was passed in or the</span><br><span class="line">                    // top view found in xml.</span><br><span class="line">                    if (root == null || !attachToRoot) &#123;</span><br><span class="line">                        result = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">                final InflateException ie = new InflateException(e.getMessage(), e);</span><br><span class="line">                ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">                throw ie;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                final InflateException ie = new InflateException(parser.getPositionDescription()</span><br><span class="line">                        + &quot;: &quot; + e.getMessage(), e);</span><br><span class="line">                ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">                throw ie;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // Don&apos;t retain static reference on context.</span><br><span class="line">                mConstructorArgs[0] = lastContext;</span><br><span class="line">                mConstructorArgs[1] = null;</span><br><span class="line"></span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">找几个关键点  </span><br><span class="line"></span><br><span class="line">1.mConstructorArgs[0] = inflaterContext;将Context传入到Objece数组ConstructorArgs中，这个后续会用到，  </span><br><span class="line">2.解析XML根布局，获取标签名称，</span><br></pre></td></tr></table></figure>
<p>if (TAG_MERGE.equals(name)) {<br>                    if (root == null || !attachToRoot) {<br>                        throw new InflateException(“<merge> can be used only with a valid “</merge></p>
<pre><code>                + &quot;ViewGroup root and attachToRoot=true&quot;);
    }

    rInflate(parser, root, inflaterContext, attrs, false);
} 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过这个代码可以知道当你的标签是merge的时候，他的跟布局不能为空，并且attachToRoot不能为false ,否则就会抛出异常，看代码学习了。  </span><br><span class="line">如果是merge标签还会走rInflate(parser, root, inflaterContext, attrs, false);咱们先看正常情况，后面也会涉及到这个方法，到时候在看是怎么处理的。  </span><br><span class="line"></span><br><span class="line">3.</span><br></pre></td></tr></table></figure>
<p> ViewGroup.LayoutParams params = null;</p>
<pre><code>    if (root != null) {
        if (DEBUG) {
            System.out.println(&quot;Creating params from root: &quot; +
                    root);
        }
        // Create layout params that match root, if supplied
        params = root.generateLayoutParams(attrs);
        if (!attachToRoot) {
            // Set the layout params for temp if we are not
            // attaching. (If we are, we use addView, below)
            temp.setLayoutParams(params);
        }
    }

    if (DEBUG) {
        System.out.println(&quot;-----&gt; start inflating children&quot;);
    }

    // Inflate all children under temp against its context.
    rInflateChildren(parser, temp, attrs, true);

    if (DEBUG) {
        System.out.println(&quot;-----&gt; done inflating children&quot;);
    }

    // We are supposed to attach all the views we found (int temp)
    // to root. Do that now.
    if (root != null &amp;&amp; attachToRoot) {
        root.addView(temp, params);
    }

    // Decide whether to return the root that was passed in or the
    // top view found in xml.
    if (root == null || !attachToRoot) {
        result = temp;
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建完跟布局后会判断当前root是否为空，如果不为空，我们通过父布局获取到对应Params属性，然后rInflateChildren继续往下进行对他的子view进行加载。最终子布局全部显示之后通过之前传过来的几个参数进行判断，  </span><br><span class="line">如果root不为空，并且attachToRoot等于True，那么久会把当前加载的view添加到父布局中，并且拿到之前父布局属性，添加进去，进行加载，如果root为空，当前加载的布局作为父布局返回。  </span><br><span class="line"></span><br><span class="line">看一下这个方法final View temp = createViewFromTag(root, name, inflaterContext, attrs);  从上面的注释可以知道可以通过这个方法返回根部布局</span><br></pre></td></tr></table></figure>
<p>View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,<br>            boolean ignoreThemeAttr) {<br>        if (name.equals(“view”)) {<br>            name = attrs.getAttributeValue(null, “class”);<br>        }</p>
<pre><code>    // Apply a theme wrapper, if allowed and one is specified.
    if (!ignoreThemeAttr) {
        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
        final int themeResId = ta.getResourceId(0, 0);
        if (themeResId != 0) {
            context = new ContextThemeWrapper(context, themeResId);
        }
        ta.recycle();
    }

    if (name.equals(TAG_1995)) {
        // Let&apos;s party like it&apos;s 1995!
        return new BlinkLayout(context, attrs);
    }

    try {
        View view;
        if (mFactory2 != null) {
            view = mFactory2.onCreateView(parent, name, context, attrs);
        } else if (mFactory != null) {
            view = mFactory.onCreateView(name, context, attrs);
        } else {
            view = null;
        }

        if (view == null &amp;&amp; mPrivateFactory != null) {
            view = mPrivateFactory.onCreateView(parent, name, context, attrs);
        }

        if (view == null) {
            final Object lastContext = mConstructorArgs[0];
            mConstructorArgs[0] = context;
            try {
                if (-1 == name.indexOf(&apos;.&apos;)) {
                    view = onCreateView(parent, name, attrs);
                } else {
                    view = createView(name, null, attrs);
                }
            } finally {
                mConstructorArgs[0] = lastContext;
            }
        }

        return view;
    } catch (InflateException e) {
        throw e;

    } catch (ClassNotFoundException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription()
                + &quot;: Error inflating class &quot; + name, e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;

    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription()
                + &quot;: Error inflating class &quot; + name, e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找几个关键点：</span><br></pre></td></tr></table></figure>
<p> if (name.equals(TAG_1995)) {<br>            // Let’s party like it’s 1995!<br>            return new BlinkLayout(context, attrs);<br>        }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.如果标签是这个1995就会返回一个BlinkLayout这个布局，有兴趣的同学可以自己引用一下，看看是什么东西，通过代码可以知道，这个布局应该是一闪一闪的。</span><br></pre></td></tr></table></figure></p>
<p>if (mFactory2 != null) {<br>                view = mFactory2.onCreateView(parent, name, context, attrs);<br>            } else if (mFactory != null) {<br>                view = mFactory.onCreateView(name, context, attrs);<br>            } else {<br>                view = null;<br>            }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<pre><code>public interface Factory {
    /**
     * Hook you can supply that is called when inflating from a LayoutInflater.
     * You can use this to customize the tag names available in your XML
     * layout files.
     *
     * &lt;p&gt;
     * Note that it is good practice to prefix these custom names with your
     * package (i.e., com.coolcompany.apps) to avoid conflicts with system
     * names.
     *
     * @param name Tag name to be inflated.
     * @param context The context the view is being created in.
     * @param attrs Inflation attributes as specified in XML file.
     *
     * @return View Newly created view. Return null for the default
     *         behavior.
     */
    public View onCreateView(String name, Context context, AttributeSet attrs);
}

public interface Factory2 extends Factory {
    /**
     * Version of {@link #onCreateView(String, Context, AttributeSet)}
     * that also supplies the parent that the view created view will be
     * placed in.
     *
     * @param parent The parent that the created view will be placed
     * in; &lt;em&gt;note that this may be null&lt;/em&gt;.
     * @param name Tag name to be inflated.
     * @param context The context the view is being created in.
     * @param attrs Inflation attributes as specified in XML file.
     *
     * @return View Newly created view. Return null for the default
     *         behavior.
     */
    public View onCreateView(View parent, String name, Context context, AttributeSet attrs);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.通过代码可以看到有两个Factory，通过工厂类获取到对应的布局，通过两个接口可以自定义View，还有一些属性，比如全局替换字体，还有更换主题什么的，这里给大家看一下使用方法吧</span><br></pre></td></tr></table></figure>
<p>public class MainActivity extends Activity {<br>    final String TAG = “MainActivity”;<br>    @Override<br>    protected void onCreate(Bundle savedInstanceState) {<br>        super.onCreate(savedInstanceState);<br>        LayoutInflater.from(this).setFactory(new LayoutInflater.Factory() {</p>
<pre><code>        @Override
        public View onCreateView(String name, Context context, AttributeSet attrs) {
            if (&quot;TextView&quot;.equals(name)) {
                Log.e(TAG, &quot;name = &quot; + name);
                int n = attrs.getAttributeCount();
                //打印所有属性标签
                for (int i = 0; i &lt; n; i++) {
                    Log.e(TAG, attrs.getAttributeName(i) + &quot; , &quot; + attrs.getAttributeValue(i));
                }
                for (int i = 0; i &lt; n; i++) {
                    if (attrs.getAttributeName(i).equals(&quot;id&quot;)) {
                        String attributeValue = attrs.getAttributeValue(i);
                        String id = attributeValue.substring(1, attributeValue.length());
                        if (R.id.text == Integer.valueOf(id)) {
                            Button button = new Button(context, attrs);
                            button.setBackgroundColor(Color.RED);
                            return button;
                        }
                    }
                }
            }
            return null;
        }
    });
    setContentView(R.layout.activity_main);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以上例子就是通过打印标签属性将TextView 替换Button，并且修改了背景颜色。ok，这个方法就先这样，我们继续看源码吧，</span><br></pre></td></tr></table></figure></p>
<p> if (view == null) {<br>                final Object lastContext = mConstructorArgs[0];<br>                mConstructorArgs[0] = context;<br>                try {<br>                    if (-1 == name.indexOf(‘.’)) {<br>                        view = onCreateView(parent, name, attrs);<br>                    } else {<br>                        view = createView(name, null, attrs);<br>                    }<br>                } finally {<br>                    mConstructorArgs[0] = lastContext;<br>                }<br>            }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">看这里如果为空的时候，判断标签中的索引是否含有.如果没有代表是系统标签走onCreateView(parent, name, attrs)，如果有代表是自定义标签走createView(name, null, attrs)这个方法，例如：com.xxx.xxx,这个就是自定义控件了。  </span><br><span class="line"></span><br><span class="line">我们继续往下看，看看onCreateView(parent, name, attrs)这个方法</span><br></pre></td></tr></table></figure></p>
<p>  protected View onCreateView(String name, AttributeSet attrs)<br>            throws ClassNotFoundException {<br>        return createView(name, “android.view.”, attrs);<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看到这里知道了，系统控件，路径是在这里补全了，&quot;android.view.&quot;最终调用的还是createView这个方法，那么咱们看看这个方法吧</span><br></pre></td></tr></table></figure></p>
<p> public final View createView(String name, String prefix, AttributeSet attrs)<br>            throws ClassNotFoundException, InflateException {<br>        Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);<br>        if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) {<br>            constructor = null;<br>            sConstructorMap.remove(name);<br>        }<br>        Class&lt;? extends View&gt; clazz = null;</p>
<pre><code>    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);

        if (constructor == null) {
            // Class not found in the cache, see if it&apos;s real, and try to add it
            clazz = mContext.getClassLoader().loadClass(
                    prefix != null ? (prefix + name) : name).asSubclass(View.class);

            if (mFilter != null &amp;&amp; clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(
                            prefix != null ? (prefix + name) : name).asSubclass(View.class);

                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }

        Object lastContext = mConstructorArgs[0];
        if (mConstructorArgs[0] == null) {
            // Fill in the context if not already within inflation.
            mConstructorArgs[0] = mContext;
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;

        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        mConstructorArgs[0] = lastContext;
        return view;
        ............
        .........
        ......
        ..
}
</code></pre><p><code>`</code><br>这里就是主要通过ClassLoader加载出来对应class，然后获取到对应的构造函数，其中也知道了为什么创建布局的时候回加载两个参数的构造函数了，通过反射得到View。  </p>
<h3 id="最后还是总结一下整体流程吧"><a href="#最后还是总结一下整体流程吧" class="headerlink" title="最后还是总结一下整体流程吧"></a>最后还是总结一下整体流程吧</h3><p><strong>LayoutInflate 通过inflate加载对应的View，通过解析对应的XML标签处理相应的view ,同事也可以通过Factory接口，获取对应的标签，达到自定义控件样式等，最后，通过ClassLoader 加载对应的Class，获取到构造函数，反射获取对应的View。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/30/LayoutInflate加载详解/" data-id="cjv3l06eo0001dslac0ken0ko" class="article-share-link">Share</a>
      
      
        <a href="/2019/04/30/LayoutInflate加载详解/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2019/04/30/LayoutInflate加载详解/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Android-View加载流程分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/30/Android-View加载流程分析/" class="article-date">
  <time datetime="2019-04-30T02:46:30.000Z" itemprop="datePublished">2019-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/30/Android-View加载流程分析/">Android View加载流程分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一章节我们讲了Activity加载的启动的流程，那么Activity启动后，是如何显示咱们的写的View的？下面咱们就开始新的旅程。 </p>
<p><img src="http://ww1.sinaimg.cn/large/007e4h7Uly1g2kgrk7swtj31g512hgq0.jpg" alt></p>
<p>首先在还记的ActivityThread在启动Activity里的onCreate()方法之前，是先调用的attach()方法，那么他为什么会调用这个方法呢，他在这个方法里干了什么呢？故事就这样开始了，不多少看一下Attach（）代码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">        Instrumentation instr, IBinder token, int ident,</span><br><span class="line">        Application application, Intent intent, ActivityInfo info,</span><br><span class="line">        CharSequence title, Activity parent, String id,</span><br><span class="line">        NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">        Window window, ActivityConfigCallback activityConfigCallback) &#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(null /*parent*/);</span><br><span class="line"></span><br><span class="line">    mWindow = new PhoneWindow(this, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(this);</span><br><span class="line">    mWindow.setCallback(this);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">    if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    .........</span><br><span class="line">    ......</span><br><span class="line">    ...</span><br><span class="line">    if (voiceInteractor != null) &#123;</span><br><span class="line">        if (lastNonConfigurationInstances != null) &#123;</span><br><span class="line">            mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,</span><br><span class="line">                    Looper.myLooper());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);</span><br><span class="line">    if (mParent != null) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line"></span><br><span class="line">    mWindow.setColorMode(info.colorMode);</span><br><span class="line"></span><br><span class="line">    setAutofillCompatibilityEnabled(application.isAutofillCompatibilityEnabled());</span><br><span class="line">    enableAutofillCompatibilityIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先创建了一个PhoneWindow对象，然后设置了WindowManager 对象，一看这个WindowManage的获取方式是通过getSystemService 获取的就知道这个也是通过binder进行获取的wms来进行管理PhoneWindow的。接下来看一下PhoneWindo 里面是如何创建。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class PhoneWindow extends Window&#123;</span><br><span class="line">    .......</span><br><span class="line">    ....</span><br><span class="line">    ..</span><br><span class="line">    /**</span><br><span class="line">     * Constructor for main window of an activity.</span><br><span class="line">     */</span><br><span class="line">    public PhoneWindow(Context context, Window preservedWindow,</span><br><span class="line">            ActivityConfigCallback activityConfigCallback) &#123;</span><br><span class="line">        this(context);</span><br><span class="line">        // Only main activity windows use decor context, all the other windows depend on whatever</span><br><span class="line">        // context that was given to them.</span><br><span class="line">        mUseDecorContext = true;</span><br><span class="line">        if (preservedWindow != null) &#123;</span><br><span class="line">            mDecor = (DecorView) preservedWindow.getDecorView();</span><br><span class="line">            mElevation = preservedWindow.getElevation();</span><br><span class="line">            mLoadElevation = false;</span><br><span class="line">            mForceDecorInstall = true;</span><br><span class="line">            // If we&apos;re preserving window, carry over the app token from the preserved</span><br><span class="line">            // window, as we&apos;ll be skipping the addView in handleResumeActivity(), and</span><br><span class="line">            // the token will not be updated as for a new window.</span><br><span class="line">            getAttributes().token = preservedWindow.getAttributes().token;</span><br><span class="line">        &#125;</span><br><span class="line">        // Even though the device doesn&apos;t support picture-in-picture mode,</span><br><span class="line">        // an user can force using it through developer options.</span><br><span class="line">        boolean forceResizable = Settings.Global.getInt(context.getContentResolver(),</span><br><span class="line">                DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES, 0) != 0;</span><br><span class="line">        mSupportsPictureInPicture = forceResizable || context.getPackageManager().hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_PICTURE_IN_PICTURE);</span><br><span class="line">        mActivityConfigCallback = activityConfigCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码可以看出来，PhoneWindow继承window。看看构造函数吧，首先判断preservedWindow != null 那么就会从这个preservedWindow里取出DecorView，那么DecorView这个类是干什么的呢.咱们进去看一下大概了解一下  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123;</span><br><span class="line">    .......</span><br><span class="line">    ....</span><br><span class="line">    ..</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看把这个是不是很熟悉，原来这个view 继承了FrameLayout，里面先不细说后面在说是怎么创建的，那么咱们往下看，看哪里？当然看onCreate()方法了，走完attach()方法就应该走onCreate() 了,我们经常在这个方法里进行布局设置setContentView()方法，咱们重点看一下在Activity类里这个方法是怎么把我们写的布局加载到视图里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">     getWindow().setContentView(layoutResID);</span><br><span class="line">     initWindowDecorActionBar();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>getWindow().setContentView(layoutResID)，看一下getWindow() 其实就是之前在attach方法里看到的PhoneWindow这个类，那么咱们看一下PhoneWindow里的setContentView 是怎么实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void setContentView(int layoutResID) &#123;</span><br><span class="line">        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br><span class="line">        // decor, when theme attributes and the like are crystalized. Do not check the feature</span><br><span class="line">        // before this happens.</span><br><span class="line">        if (mContentParent == null) &#123;</span><br><span class="line">            installDecor();</span><br><span class="line">        &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            mContentParent.removeAllViews();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                    getContext());</span><br><span class="line">            transitionTo(newScene);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParent.requestApplyInsets();</span><br><span class="line">        final Callback cb = getCallback();</span><br><span class="line">        if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">            cb.onContentChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParentExplicitlySet = true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先判断if (mContentParent == null) mContentParent是一个ViewGroup，如果这个是空那么执行installDecor()方法，咱们看一下这个方法干了什么事情  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">private void installDecor() &#123;</span><br><span class="line">       mForceDecorInstall = false;</span><br><span class="line">       if (mDecor == null) &#123;</span><br><span class="line">           mDecor = generateDecor(-1);</span><br><span class="line">           mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">           mDecor.setIsRootNamespace(true);</span><br><span class="line">           if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123;</span><br><span class="line">               mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           mDecor.setWindow(this);</span><br><span class="line">       &#125;</span><br><span class="line">       if (mContentParent == null) &#123;</span><br><span class="line">           mContentParent = generateLayout(mDecor);</span><br><span class="line"></span><br><span class="line">           // Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span><br><span class="line">           mDecor.makeOptionalFitsSystemWindows();</span><br><span class="line"></span><br><span class="line">           final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class="line">                   R.id.decor_content_parent);</span><br><span class="line"></span><br><span class="line">           if (decorContentParent != null) &#123;</span><br><span class="line">               mDecorContentParent = decorContentParent;</span><br><span class="line">               mDecorContentParent.setWindowCallback(getCallback());</span><br><span class="line">               if (mDecorContentParent.getTitle() == null) &#123;</span><br><span class="line">                   mDecorContentParent.setWindowTitle(mTitle);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final int localFeatures = getLocalFeatures();</span><br><span class="line">               for (int i = 0; i &lt; FEATURE_MAX; i++) &#123;</span><br><span class="line">                   if ((localFeatures &amp; (1 &lt;&lt; i)) != 0) &#123;</span><br><span class="line">                       mDecorContentParent.initFeature(i);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               mDecorContentParent.setUiOptions(mUiOptions);</span><br><span class="line"></span><br><span class="line">               if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) != 0 ||</span><br><span class="line">                       (mIconRes != 0 &amp;&amp; !mDecorContentParent.hasIcon())) &#123;</span><br><span class="line">                   mDecorContentParent.setIcon(mIconRes);</span><br><span class="line">               &#125; else if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) == 0 &amp;&amp;</span><br><span class="line">                       mIconRes == 0 &amp;&amp; !mDecorContentParent.hasIcon()) &#123;</span><br><span class="line">                   mDecorContentParent.setIcon(</span><br><span class="line">                           getContext().getPackageManager().getDefaultActivityIcon());</span><br><span class="line">                   mResourcesSetFlags |= FLAG_RESOURCE_SET_ICON_FALLBACK;</span><br><span class="line">               &#125;</span><br><span class="line">               if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_LOGO) != 0 ||</span><br><span class="line">                       (mLogoRes != 0 &amp;&amp; !mDecorContentParent.hasLogo())) &#123;</span><br><span class="line">                   mDecorContentParent.setLogo(mLogoRes);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // Invalidate if the panel menu hasn&apos;t been created before this.</span><br><span class="line">               // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu</span><br><span class="line">               // being called in the middle of onCreate or similar.</span><br><span class="line">               // A pending invalidation will typically be resolved before the posted message</span><br><span class="line">               // would run normally in order to satisfy instance state restoration.</span><br><span class="line">               PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false);</span><br><span class="line">               if (!isDestroyed() &amp;&amp; (st == null || st.menu == null) &amp;&amp; !mIsStartingWindow) &#123;</span><br><span class="line">                   invalidatePanelMenu(FEATURE_ACTION_BAR);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               mTitleView = findViewById(R.id.title);</span><br><span class="line">               if (mTitleView != null) &#123;</span><br><span class="line">                   if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123;</span><br><span class="line">                       final View titleContainer = findViewById(R.id.title_container);</span><br><span class="line">                       if (titleContainer != null) &#123;</span><br><span class="line">                           titleContainer.setVisibility(View.GONE);</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           mTitleView.setVisibility(View.GONE);</span><br><span class="line">                       &#125;</span><br><span class="line">                       mContentParent.setForeground(null);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       mTitleView.setText(mTitle);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (mDecor.getBackground() == null &amp;&amp; mBackgroundFallbackResource != 0) &#123;</span><br><span class="line">               mDecor.setBackgroundFallback(mBackgroundFallbackResource);</span><br><span class="line">           &#125;</span><br><span class="line">       .............</span><br><span class="line">       ....</span><br><span class="line">       ...</span><br><span class="line">       .</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>看这个判断if (mDecor == null) 这个就是咱们之前看到的DecorView这个类，如果是空就走generateDecor这个方法，接下来看一下这个方法怎么实现的  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected DecorView generateDecor(int featureId) &#123;</span><br><span class="line">        // System process doesn&apos;t have application context and in that case we need to directly use</span><br><span class="line">        // the context we have. Otherwise we want the application context, so we don&apos;t cling to the</span><br><span class="line">        // activity.</span><br><span class="line">        Context context;</span><br><span class="line">        if (mUseDecorContext) &#123;</span><br><span class="line">            Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">            if (applicationContext == null) &#123;</span><br><span class="line">                context = getContext();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                context = new DecorContext(applicationContext, getContext());</span><br><span class="line">                if (mTheme != -1) &#123;</span><br><span class="line">                    context.setTheme(mTheme);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            context = getContext();</span><br><span class="line">        &#125;</span><br><span class="line">        return new DecorView(context, featureId, this, getAttributes());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很简单就是创建了一个DecorView对象，那么还是回到上个方法看一下，有了DecorView这个类，咱们往下走，if (mContentParent == null) ，判断mContentParent是否为空，mContentParent就是一个ViewGroup，如果为空就会通过mContentParent = generateLayout(mDecor);<br>通过这个方法创建一个，还是看看这个方法都看了什么  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</span><br><span class="line">     // Apply data from current theme.</span><br><span class="line"></span><br><span class="line">     TypedArray a = getWindowStyle();</span><br><span class="line">     ..................</span><br><span class="line">     ...............</span><br><span class="line">     ............</span><br><span class="line">        if (a.getBoolean(R.styleable.Window_windowTranslucentStatus,</span><br><span class="line">             false)) &#123;</span><br><span class="line">         setFlags(FLAG_TRANSLUCENT_STATUS, FLAG_TRANSLUCENT_STATUS</span><br><span class="line">                 &amp; (~getForcedWindowFlags()));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (a.getBoolean(R.styleable.Window_windowTranslucentNavigation,</span><br><span class="line">             false)) &#123;</span><br><span class="line">         setFlags(FLAG_TRANSLUCENT_NAVIGATION, FLAG_TRANSLUCENT_NAVIGATION</span><br><span class="line">                 &amp; (~getForcedWindowFlags()));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (a.getBoolean(R.styleable.Window_windowOverscan, false)) &#123;</span><br><span class="line">         setFlags(FLAG_LAYOUT_IN_OVERSCAN, FLAG_LAYOUT_IN_OVERSCAN&amp;(~getForcedWindowFlags()));</span><br><span class="line">     &#125;</span><br><span class="line">     .........</span><br><span class="line">     .....</span><br><span class="line">     ...</span><br><span class="line">     .</span><br><span class="line">      mDecor.startChanging();</span><br><span class="line">     mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">     ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">     if (contentParent == null) &#123;</span><br><span class="line">         throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) &#123;</span><br><span class="line">         ProgressBar progress = getCircularProgressBar(false);</span><br><span class="line">         if (progress != null) &#123;</span><br><span class="line">             progress.setIndeterminate(true);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123;</span><br><span class="line">         registerSwipeCallbacks(contentParent);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // Remaining setup -- of background and title -- that only applies</span><br><span class="line">     // to top-level windows.</span><br><span class="line">     if (getContainer() == null) &#123;</span><br><span class="line">         final Drawable background;</span><br><span class="line">         if (mBackgroundResource != 0) &#123;</span><br><span class="line">             background = getContext().getDrawable(mBackgroundResource);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             background = mBackgroundDrawable;</span><br><span class="line">         &#125;</span><br><span class="line">         mDecor.setWindowBackground(background);</span><br><span class="line"></span><br><span class="line">         final Drawable frame;</span><br><span class="line">         if (mFrameResource != 0) &#123;</span><br><span class="line">             frame = getContext().getDrawable(mFrameResource);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             frame = null;</span><br><span class="line">         &#125;</span><br><span class="line">         mDecor.setWindowFrame(frame);</span><br><span class="line"></span><br><span class="line">         mDecor.setElevation(mElevation);</span><br><span class="line">         mDecor.setClipToOutline(mClipToOutline);</span><br><span class="line"></span><br><span class="line">         if (mTitle != null) &#123;</span><br><span class="line">             setTitle(mTitle);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (mTitleColor == 0) &#123;</span><br><span class="line">             mTitleColor = mTextColor;</span><br><span class="line">         &#125;</span><br><span class="line">         setTitleColor(mTitleColor);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mDecor.finishChanging();</span><br><span class="line"></span><br><span class="line">     return contentParent;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>代码太长，找一些重点讲一下， ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT)  主要就是通过这个获取mContentParent 这个com.android.internal.R.id.content是不是很熟悉。 这样就把之前咱们传进来的布局跟DecorView添加到id为content里布局里了mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);<br>就是设置一下Activity的主题等。咱们在回过头看，在看 setContentView（）方法，获取到mContentParent，            mLayoutInflater.inflate(layoutResID, mContentParent);<br>就会执行这个方法，这个方法很熟悉，我们在通过布局创建view 的时候都会调用这个，最终会把布局inflate，mContentParent中，如果想细看LayoutInflater.inflate里的具体流程，看一下看我的另外一篇文章有专门对他进行讲解，<a href="https://pqmpqm123.github.io/2019/04/30/LayoutInflate%E5%8A%A0%E8%BD%BD%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">LayoutInflate加载详解</a>  ,这里就不在详解了，否则太长了。<br>现在DecorView也已经有了，咱们写的布局文件添加到mContentParent里了，接下来看看是怎么显示的吧，大家知道activity 启动的时候是走到onResume里的时候会显示出布局获取到焦点，那么看一下ActivityThread 里走到onResume里都做了什么  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,</span><br><span class="line">           String reason) &#123;</span><br><span class="line">       // If we are getting ready to gc after going to the background, well</span><br><span class="line">       // we are back active so skip it.</span><br><span class="line">       unscheduleGcIdler();</span><br><span class="line">       mSomeActivitiesChanged = true;</span><br><span class="line"></span><br><span class="line">       // TODO Push resumeArgs into the activity for consideration</span><br><span class="line">       final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">       </span><br><span class="line">   </span><br><span class="line">           r.activity.mVisibleFromServer = true;</span><br><span class="line">           mNumVisibleActivities++;</span><br><span class="line">           if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">               r.activity.makeVisible();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       r.nextIdle = mNewActivities;</span><br><span class="line">       mNewActivities = r;</span><br><span class="line">       if (localLOGV) Slog.v(TAG, &quot;Scheduling idle handler for &quot; + r);</span><br><span class="line">       Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>重点看这里哦，r.activity.makeVisible()在进入activity里看一下这个方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void makeVisible() &#123;</span><br><span class="line">    if (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = true;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要就是将之前创建的DecorView添加到WindowMager,并且设置mDecor.setVisibility(View.VISIBLE);那么getWindowManager方法就是之前在attach方法是创建的WindowManager,WindowManager是一个接口，看一下哪里实现了这个接口呢，按之前读源码的规则看实现类应该是WindowManagerImpl,看看还真有这个类。那么看看这个类是怎么实现的addView方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class WindowManagerImpl implements WindowManager &#123;</span><br><span class="line">      @Override</span><br><span class="line">    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow),mGlobal是什么呢，看看一下WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance()，看来这是个单例，全局都是这一个管理，那进去看看把  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">          Display display, Window parentWindow) &#123;</span><br><span class="line">      if (view == null) &#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;view must not be null&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (display == null) &#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;display must not be null&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (!(params instanceof WindowManager.LayoutParams)) &#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">      if (parentWindow != null) &#123;</span><br><span class="line">          parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          // If there&apos;s no parent, then hardware acceleration for this view is</span><br><span class="line">          // set from the application&apos;s hardware acceleration setting.</span><br><span class="line">          final Context context = view.getContext();</span><br><span class="line">          if (context != null</span><br><span class="line">                  &amp;&amp; (context.getApplicationInfo().flags</span><br><span class="line">                          &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123;</span><br><span class="line">              wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ViewRootImpl root;</span><br><span class="line">      View panelParentView = null;</span><br><span class="line"></span><br><span class="line">      synchronized (mLock) &#123;</span><br><span class="line">          // Start watching for system property changes.</span><br><span class="line">          if (mSystemPropertyUpdater == null) &#123;</span><br><span class="line">              mSystemPropertyUpdater = new Runnable() &#123;</span><br><span class="line">                  @Override public void run() &#123;</span><br><span class="line">                      synchronized (mLock) &#123;</span><br><span class="line">                          for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">                              mRoots.get(i).loadSystemProperties();</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;;</span><br><span class="line">              SystemProperties.addChangeCallback(mSystemPropertyUpdater);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          int index = findViewLocked(view, false);</span><br><span class="line">          if (index &gt;= 0) &#123;</span><br><span class="line">              if (mDyingViews.contains(view)) &#123;</span><br><span class="line">                  // Don&apos;t wait for MSG_DIE to make it&apos;s way through root&apos;s queue.</span><br><span class="line">                  mRoots.get(index).doDie();</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  throw new IllegalStateException(&quot;View &quot; + view</span><br><span class="line">                          + &quot; has already been added to the window manager.&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              // The previous removeView() had not completed executing. Now it has.</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // If this is a panel window, then find the window it is being</span><br><span class="line">          // attached to for future reference.</span><br><span class="line">          if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                  wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">              final int count = mViews.size();</span><br><span class="line">              for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                  if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;</span><br><span class="line">                      panelParentView = mViews.get(i);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">          view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">          mViews.add(view);</span><br><span class="line">          mRoots.add(root);</span><br><span class="line">          mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">          // do this last because it fires off messages to start doing things</span><br><span class="line">          try &#123;</span><br><span class="line">              root.setView(view, wparams, panelParentView);</span><br><span class="line">          &#125; catch (RuntimeException e) &#123;</span><br><span class="line">              // BadTokenException or InvalidDisplayException, clean up.</span><br><span class="line">              if (index &gt;= 0) &#123;</span><br><span class="line">                  removeViewLocked(index, true);</span><br><span class="line">              &#125;</span><br><span class="line">              throw e;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>看到addView方法里知道里面重点是，创建了一个ViewRootImpl对象，并且维护了三个链表，一个是View链表,就是传过来的DecorView，然后就是mRoots链表存放着当前创建的ViewRootImpl这个对象，还有就是mParams链表，存放的是LayoutParams属性。然后将view set到ViewRootImpl里，重点看一下这里做了什么  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line"></span><br><span class="line">      if (mView == null) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line"></span><br><span class="line">            mAttachInfo.mDisplayState = mDisplay.getState();</span><br><span class="line">            mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);</span><br><span class="line"></span><br><span class="line">            mViewLayoutDirectionInitial = mView.getRawLayoutDirection();</span><br><span class="line">            mFallbackEventHandler.setView(view);</span><br><span class="line">            mWindowAttributes.copyFrom(attrs);</span><br><span class="line">            if (mWindowAttributes.packageName == null) &#123;</span><br><span class="line">                mWindowAttributes.packageName = mBasePackageName;</span><br><span class="line">            &#125;</span><br><span class="line">            attrs = mWindowAttributes;</span><br><span class="line">            setTag();</span><br><span class="line"></span><br><span class="line">            if (DEBUG_KEEP_SCREEN_ON &amp;&amp; (mClientWindowLayoutFlags</span><br><span class="line">                    &amp; WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON) != 0</span><br><span class="line">                    &amp;&amp; (attrs.flags&amp;WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON) == 0) &#123;</span><br><span class="line">                Slog.d(mTag, &quot;setView: FLAG_KEEP_SCREEN_ON changed from true to false!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // Keep track of the actual window flags supplied by the client.</span><br><span class="line">            mClientWindowLayoutFlags = attrs.flags;</span><br><span class="line"></span><br><span class="line">            setAccessibilityFocus(null, null);</span><br><span class="line"></span><br><span class="line">            if (view instanceof RootViewSurfaceTaker) &#123;</span><br><span class="line">                mSurfaceHolderCallback =</span><br><span class="line">                        ((RootViewSurfaceTaker)view).willYouTakeTheSurface();</span><br><span class="line">                if (mSurfaceHolderCallback != null) &#123;</span><br><span class="line">                    mSurfaceHolder = new TakenSurfaceHolder();</span><br><span class="line">                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);</span><br><span class="line">                    mSurfaceHolder.addCallback(mSurfaceHolderCallback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Compute surface insets required to draw at specified Z value.</span><br><span class="line">            // TODO: Use real shadow insets for a constant max Z.</span><br><span class="line">            if (!attrs.hasManualSurfaceInsets) &#123;</span><br><span class="line">                attrs.setSurfaceInsets(view, false /*manual*/, true /*preservePrevious*/);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CompatibilityInfo compatibilityInfo =</span><br><span class="line">                    mDisplay.getDisplayAdjustments().getCompatibilityInfo();</span><br><span class="line">            mTranslator = compatibilityInfo.getTranslator();</span><br><span class="line"></span><br><span class="line">            // If the application owns the surface, don&apos;t enable hardware acceleration</span><br><span class="line">            if (mSurfaceHolder == null) &#123;</span><br><span class="line">                // While this is supposed to enable only, it can effectively disable</span><br><span class="line">                // the acceleration too.</span><br><span class="line">                enableHardwareAcceleration(attrs);</span><br><span class="line">                final boolean useMTRenderer = MT_RENDERER_AVAILABLE</span><br><span class="line">                        &amp;&amp; mAttachInfo.mThreadedRenderer != null;</span><br><span class="line">                if (mUseMTRenderer != useMTRenderer) &#123;</span><br><span class="line">                    // Shouldn&apos;t be resizing, as it&apos;s done only in window setup,</span><br><span class="line">                    // but end just in case.</span><br><span class="line">                    endDragResizing();</span><br><span class="line">                    mUseMTRenderer = useMTRenderer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean restore = false;</span><br><span class="line">            if (mTranslator != null) &#123;</span><br><span class="line">                mSurface.setCompatibilityTranslator(mTranslator);</span><br><span class="line">                restore = true;</span><br><span class="line">                attrs.backup();</span><br><span class="line">                mTranslator.translateWindowLayout(attrs);</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG_LAYOUT) Log.d(mTag, &quot;WindowLayout in setView:&quot; + attrs);</span><br><span class="line"></span><br><span class="line">            if (!compatibilityInfo.supportsScreen()) &#123;</span><br><span class="line">                attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">                mLastInCompatMode = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mSoftInputMode = attrs.softInputMode;</span><br><span class="line">            mWindowAttributesChanged = true;</span><br><span class="line">            mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;</span><br><span class="line">            mAttachInfo.mRootView = view;</span><br><span class="line">            mAttachInfo.mScalingRequired = mTranslator != null;</span><br><span class="line">            mAttachInfo.mApplicationScale =</span><br><span class="line">                    mTranslator == null ? 1.0f : mTranslator.applicationScale;</span><br><span class="line">            if (panelParentView != null) &#123;</span><br><span class="line">                mAttachInfo.mPanelParentWindowToken</span><br><span class="line">                        = panelParentView.getApplicationWindowToken();</span><br><span class="line">            &#125;</span><br><span class="line">            mAdded = true;</span><br><span class="line">            int res; /* = WindowManagerImpl.ADD_OKAY; */</span><br><span class="line"></span><br><span class="line">            // Schedule the first layout -before- adding to the window</span><br><span class="line">            // manager, to make sure we do the relayout before receiving</span><br><span class="line">            // any other events from the system.</span><br><span class="line">            requestLayout();</span><br><span class="line">            ..............</span><br><span class="line">            ............</span><br><span class="line">            .....</span><br><span class="line">            ..</span><br><span class="line">            .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看代码有两处重点，一个就是将view交给了ViewRootimpl处理，ViewRootimpl类里主要对View进行绘制，和事件的操作，然后调用了requestLayout()方法，那么咱们看一下requestLayout()这个方法是怎么处理的。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void requestLayout() &#123;</span><br><span class="line">      if (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">          checkThread();</span><br><span class="line">          mLayoutRequested = true;</span><br><span class="line">          scheduleTraversals();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下scheduleTraversals()方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">    if (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = true;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">        if (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下mTraversalRunnable里面执行了什么  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final class TraversalRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">final TraversalRunnable mTraversalRunnable = new TraversalRunnable();</span><br></pre></td></tr></table></figure>
<p>==看一下doTraversal这个方法== 回来重点看一下 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void doTraversal() &#123;</span><br><span class="line">    if (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = false;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">        if (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(&quot;ViewAncestor&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        performTraversals();</span><br><span class="line"></span><br><span class="line">        if (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看一下这里performTraversals()这个方法吧  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    .....</span><br><span class="line">    重点看这几个方法吧</span><br><span class="line"> if (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">                boolean focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);</span><br><span class="line">                if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                        || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||</span><br><span class="line">                        updatedConfiguration) &#123;</span><br><span class="line">                    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Ooops, something changed!  mWidth=&quot;</span><br><span class="line">                            + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth()</span><br><span class="line">                            + &quot; mHeight=&quot; + mHeight</span><br><span class="line">                            + &quot; measuredHeight=&quot; + host.getMeasuredHeight()</span><br><span class="line">                            + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged);</span><br><span class="line"></span><br><span class="line">                     // Ask host how big it wants to be</span><br><span class="line">                    //注释1</span><br><span class="line"></span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                    // Implementation of weights from WindowManager.LayoutParams</span><br><span class="line">                    // We just grow the dimensions as needed and re-measure if</span><br><span class="line">                    // needs be</span><br><span class="line">                    int width = host.getMeasuredWidth();</span><br><span class="line">                    int height = host.getMeasuredHeight();</span><br><span class="line">                    boolean measureAgain = false;</span><br><span class="line"></span><br><span class="line">                    if (lp.horizontalWeight &gt; 0.0f) &#123;</span><br><span class="line">                        width += (int) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                        childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (lp.verticalWeight &gt; 0.0f) &#123;</span><br><span class="line">                        height += (int) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain = true;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (measureAgain) &#123;</span><br><span class="line">                        if (DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">                                &quot;And hey let&apos;s measure once more: width=&quot; + width</span><br><span class="line">                                + &quot; height=&quot; + height);</span><br><span class="line">                        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    layoutRequested = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Not the first pass and no window/insets/visibility change but the window</span><br><span class="line">            // may have moved and we need check that and if so to update the left and right</span><br><span class="line">            // in the attach info. We translate only the window frame since on window move</span><br><span class="line">            // the window manager tells us only for the new frame but the insets are the</span><br><span class="line">            // same and we do not want to translate them more than once.</span><br><span class="line">            maybeHandleWindowMove(frame);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">        boolean triggerGlobalLayoutListener = didLayout</span><br><span class="line">                || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">        if (didLayout) &#123;</span><br><span class="line">        //注释2</span><br><span class="line">            performLayout(lp, mWidth, mHeight);</span><br><span class="line"></span><br><span class="line">            // By this point all views have been sized and positioned</span><br><span class="line">            // We can compute the transparent area</span><br><span class="line"></span><br><span class="line">            if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) &#123;</span><br><span class="line">                // start out transparent</span><br><span class="line">                // TODO: AVOID THAT CALL BY CACHING THE RESULT?</span><br><span class="line">                host.getLocationInWindow(mTmpLocation);</span><br><span class="line">                mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1],</span><br><span class="line">                        mTmpLocation[0] + host.mRight - host.mLeft,</span><br><span class="line">                        mTmpLocation[1] + host.mBottom - host.mTop);</span><br><span class="line"></span><br><span class="line">                host.gatherTransparentRegion(mTransparentRegion);</span><br><span class="line">                if (mTranslator != null) &#123;</span><br><span class="line">                    mTranslator.translateRegionInWindowToScreen(mTransparentRegion);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123;</span><br><span class="line">                    mPreviousTransparentRegion.set(mTransparentRegion);</span><br><span class="line">                    mFullRedrawNeeded = true;</span><br><span class="line">                    // reconfigure window manager</span><br><span class="line">                    try &#123;</span><br><span class="line">                        mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (DBG) &#123;</span><br><span class="line">                System.out.println(&quot;======================================&quot;);</span><br><span class="line">                System.out.println(&quot;performTraversals -- after setFrame&quot;);</span><br><span class="line">                host.debug();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (triggerGlobalLayoutListener) &#123;</span><br><span class="line">            mAttachInfo.mRecomputeGlobalAttributes = false;</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (computesInternalInsets) &#123;</span><br><span class="line">            // Clear the original insets.</span><br><span class="line">            final ViewTreeObserver.InternalInsetsInfo insets = mAttachInfo.mGivenInternalInsets;</span><br><span class="line">            insets.reset();</span><br><span class="line"></span><br><span class="line">            // Compute new insets in place.</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);</span><br><span class="line">            mAttachInfo.mHasNonEmptyGivenInternalInsets = !insets.isEmpty();</span><br><span class="line"></span><br><span class="line">            // Tell the window manager.</span><br><span class="line">            if (insetsPending || !mLastGivenInsets.equals(insets)) &#123;</span><br><span class="line">                mLastGivenInsets.set(insets);</span><br><span class="line"></span><br><span class="line">                // Translate insets to screen coordinates if needed.</span><br><span class="line">                final Rect contentInsets;</span><br><span class="line">                final Rect visibleInsets;</span><br><span class="line">                final Region touchableRegion;</span><br><span class="line">                if (mTranslator != null) &#123;</span><br><span class="line">                    contentInsets = mTranslator.getTranslatedContentInsets(insets.contentInsets);</span><br><span class="line">                    visibleInsets = mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);</span><br><span class="line">                    touchableRegion = mTranslator.getTranslatedTouchableArea(insets.touchableRegion);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    contentInsets = insets.contentInsets;</span><br><span class="line">                    visibleInsets = insets.visibleInsets;</span><br><span class="line">                    touchableRegion = insets.touchableRegion;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    mWindowSession.setInsets(mWindow, insets.mTouchableInsets,</span><br><span class="line">                            contentInsets, visibleInsets, touchableRegion);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mFirst) &#123;</span><br><span class="line">            if (sAlwaysAssignFocus || !isInTouchMode()) &#123;</span><br><span class="line">                // handle first focus request</span><br><span class="line">                if (DEBUG_INPUT_RESIZE) &#123;</span><br><span class="line">                    Log.v(mTag, &quot;First: mView.hasFocus()=&quot; + mView.hasFocus());</span><br><span class="line">                &#125;</span><br><span class="line">                if (mView != null) &#123;</span><br><span class="line">                    if (!mView.hasFocus()) &#123;</span><br><span class="line">                        mView.restoreDefaultFocus();</span><br><span class="line">                        if (DEBUG_INPUT_RESIZE) &#123;</span><br><span class="line">                            Log.v(mTag, &quot;First: requested focused view=&quot; + mView.findFocus());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (DEBUG_INPUT_RESIZE) &#123;</span><br><span class="line">                            Log.v(mTag, &quot;First: existing focused view=&quot; + mView.findFocus());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Some views (like ScrollView) won&apos;t hand focus to descendants that aren&apos;t within</span><br><span class="line">                // their viewport. Before layout, there&apos;s a good change these views are size 0</span><br><span class="line">                // which means no children can get focus. After layout, this view now has size, but</span><br><span class="line">                // is not guaranteed to hand-off focus to a focusable child (specifically, the edge-</span><br><span class="line">                // case where the child has a size prior to layout and thus won&apos;t trigger</span><br><span class="line">                // focusableViewAvailable).</span><br><span class="line">                View focused = mView.findFocus();</span><br><span class="line">                if (focused instanceof ViewGroup</span><br><span class="line">                        &amp;&amp; ((ViewGroup) focused).getDescendantFocusability()</span><br><span class="line">                                == ViewGroup.FOCUS_AFTER_DESCENDANTS) &#123;</span><br><span class="line">                    focused.restoreDefaultFocus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean changedVisibility = (viewVisibilityChanged || mFirst) &amp;&amp; isViewVisible;</span><br><span class="line">        final boolean hasWindowFocus = mAttachInfo.mHasWindowFocus &amp;&amp; isViewVisible;</span><br><span class="line">        final boolean regainedFocus = hasWindowFocus &amp;&amp; mLostWindowFocus;</span><br><span class="line">        if (regainedFocus) &#123;</span><br><span class="line">            mLostWindowFocus = false;</span><br><span class="line">        &#125; else if (!hasWindowFocus &amp;&amp; mHadWindowFocus) &#123;</span><br><span class="line">            mLostWindowFocus = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (changedVisibility || regainedFocus) &#123;</span><br><span class="line">            // Toasts are presented as notifications - don&apos;t present them as windows as well</span><br><span class="line">            boolean isToast = (mWindowAttributes == null) ? false</span><br><span class="line">                    : (mWindowAttributes.type == WindowManager.LayoutParams.TYPE_TOAST);</span><br><span class="line">            if (!isToast) &#123;</span><br><span class="line">                host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFirst = false;</span><br><span class="line">        mWillDrawSoon = false;</span><br><span class="line">        mNewSurfaceNeeded = false;</span><br><span class="line">        mActivityRelaunched = false;</span><br><span class="line">        mViewVisibility = viewVisibility;</span><br><span class="line">        mHadWindowFocus = hasWindowFocus;</span><br><span class="line"></span><br><span class="line">        if (hasWindowFocus &amp;&amp; !isInLocalFocusMode()) &#123;</span><br><span class="line">            final boolean imTarget = WindowManager.LayoutParams</span><br><span class="line">                    .mayUseInputMethod(mWindowAttributes.flags);</span><br><span class="line">            if (imTarget != mLastWasImTarget) &#123;</span><br><span class="line">                mLastWasImTarget = imTarget;</span><br><span class="line">                InputMethodManager imm = InputMethodManager.peekInstance();</span><br><span class="line">                if (imm != null &amp;&amp; imTarget) &#123;</span><br><span class="line">                    imm.onPreWindowFocus(mView, hasWindowFocus);</span><br><span class="line">                    imm.onPostWindowFocus(mView, mView.findFocus(),</span><br><span class="line">                            mWindowAttributes.softInputMode,</span><br><span class="line">                            !mHasHadWindowFocus, mWindowAttributes.flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Remember if we must report the next draw.</span><br><span class="line">        if ((relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) &#123;</span><br><span class="line">            reportNextDraw();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;</span><br><span class="line"></span><br><span class="line">        if (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">            if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">                for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        //注释3</span><br><span class="line">            performDraw();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (isViewVisible) &#123;</span><br><span class="line">                // Try again</span><br><span class="line">                scheduleTraversals();</span><br><span class="line">            &#125; else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">                for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).endChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mIsInTraversal = false;</span><br><span class="line">    ...........</span><br><span class="line">    ........</span><br><span class="line">    .....</span><br><span class="line">    ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟进我标注的注释1，2，3是不是很熟悉，分别是  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);performLayout(lp, mWidth, mHeight);performDraw();这三个方法，测量，布局，还有绘制，那么咱们分别跟进这几个方法看看最终是怎么调用的  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</span><br><span class="line">    if (mView == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用的是 mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); 看一下View是怎么实现的  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        boolean optical = isLayoutModeOptical(this);</span><br><span class="line">        if (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">            Insets insets = getOpticalInsets();</span><br><span class="line">            int oWidth  = insets.left + insets.right;</span><br><span class="line">            int oHeight = insets.top  + insets.bottom;</span><br><span class="line">            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</span><br><span class="line">            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Suppress sign extension for the low bytes</span><br><span class="line">        long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;</span><br><span class="line">        if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);</span><br><span class="line"></span><br><span class="line">        final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</span><br><span class="line"></span><br><span class="line">        // Optimize layout by avoiding an extra EXACTLY pass when the view is</span><br><span class="line">        // already measured as the correct size. In API 23 and below, this</span><br><span class="line">        // extra pass is required to make LinearLayout re-distribute weight.</span><br><span class="line">        final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec</span><br><span class="line">                || heightMeasureSpec != mOldHeightMeasureSpec;</span><br><span class="line">        final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY</span><br><span class="line">                &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;</span><br><span class="line">        final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">                &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        final boolean needsLayout = specChanged</span><br><span class="line">                &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);</span><br><span class="line"></span><br><span class="line">        if (forceLayout || needsLayout) &#123;</span><br><span class="line">            // first clears the measured dimension flag</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line"></span><br><span class="line">            resolveRtlPropertiesIfNeeded();</span><br><span class="line"></span><br><span class="line">            int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);</span><br><span class="line">            if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;</span><br><span class="line">                // measure ourselves, this should set the measured dimension flag back</span><br><span class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                long value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">                // Casting a long to int drops the high 32 bits, no mask needed</span><br><span class="line">                setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);</span><br><span class="line">                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // flag not set, setMeasuredDimension() was not invoked, we raise</span><br><span class="line">            // an exception to warn the developer</span><br><span class="line">            if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot;</span><br><span class="line">                        + getClass().getName() + &quot;#onMeasure() did not set the&quot;</span><br><span class="line">                        + &quot; measured dimension by calling&quot;</span><br><span class="line">                        + &quot; setMeasuredDimension()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">        mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line"></span><br><span class="line">        mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 |</span><br><span class="line">                (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这么多代码，挑出重点,onMeasure(widthMeasureSpec, heightMeasureSpec);这个是不是最熟悉了，在做自定义View的时候经常用到吧，那么在往下看看这个方法是怎么掉用的，还记的之前传过来的View应该是DecorView，那么看看这个类有没有实现onMeasure(widthMeasureSpec, heightMeasureSpec);这个方法。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">      final DisplayMetrics metrics = getContext().getResources().getDisplayMetrics();</span><br><span class="line">      final boolean isPortrait =</span><br><span class="line">              getResources().getConfiguration().orientation == ORIENTATION_PORTRAIT;</span><br><span class="line"></span><br><span class="line">      final int widthMode = getMode(widthMeasureSpec);</span><br><span class="line">      final int heightMode = getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">      boolean fixedWidth = false;</span><br><span class="line">      mApplyFloatingHorizontalInsets = false;</span><br><span class="line">      if (widthMode == AT_MOST) &#123;</span><br><span class="line">          final TypedValue tvw = isPortrait ? mWindow.mFixedWidthMinor : mWindow.mFixedWidthMajor;</span><br><span class="line">          if (tvw != null &amp;&amp; tvw.type != TypedValue.TYPE_NULL) &#123;</span><br><span class="line">              final int w;</span><br><span class="line">              if (tvw.type == TypedValue.TYPE_DIMENSION) &#123;</span><br><span class="line">                  w = (int) tvw.getDimension(metrics);</span><br><span class="line">              &#125; else if (tvw.type == TypedValue.TYPE_FRACTION) &#123;</span><br><span class="line">                  w = (int) tvw.getFraction(metrics.widthPixels, metrics.widthPixels);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  w = 0;</span><br><span class="line">              &#125;</span><br><span class="line">              if (DEBUG_MEASURE) Log.d(mLogTag, &quot;Fixed width: &quot; + w);</span><br><span class="line">              final int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">              if (w &gt; 0) &#123;</span><br><span class="line">                  widthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                          Math.min(w, widthSize), EXACTLY);</span><br><span class="line">                  fixedWidth = true;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  widthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                          widthSize - mFloatingInsets.left - mFloatingInsets.right,</span><br><span class="line">                          AT_MOST);</span><br><span class="line">                  mApplyFloatingHorizontalInsets = true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mApplyFloatingVerticalInsets = false;</span><br><span class="line">      if (heightMode == AT_MOST) &#123;</span><br><span class="line">          final TypedValue tvh = isPortrait ? mWindow.mFixedHeightMajor</span><br><span class="line">                  : mWindow.mFixedHeightMinor;</span><br><span class="line">          if (tvh != null &amp;&amp; tvh.type != TypedValue.TYPE_NULL) &#123;</span><br><span class="line">              final int h;</span><br><span class="line">              if (tvh.type == TypedValue.TYPE_DIMENSION) &#123;</span><br><span class="line">                  h = (int) tvh.getDimension(metrics);</span><br><span class="line">              &#125; else if (tvh.type == TypedValue.TYPE_FRACTION) &#123;</span><br><span class="line">                  h = (int) tvh.getFraction(metrics.heightPixels, metrics.heightPixels);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  h = 0;</span><br><span class="line">              &#125;</span><br><span class="line">              if (DEBUG_MEASURE) Log.d(mLogTag, &quot;Fixed height: &quot; + h);</span><br><span class="line">              final int heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">              if (h &gt; 0) &#123;</span><br><span class="line">                  heightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                          Math.min(h, heightSize), EXACTLY);</span><br><span class="line">              &#125; else if ((mWindow.getAttributes().flags &amp; FLAG_LAYOUT_IN_SCREEN) == 0) &#123;</span><br><span class="line">                  heightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                          heightSize - mFloatingInsets.top - mFloatingInsets.bottom, AT_MOST);</span><br><span class="line">                  mApplyFloatingVerticalInsets = true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      getOutsets(mOutsets);</span><br><span class="line">      if (mOutsets.top &gt; 0 || mOutsets.bottom &gt; 0) &#123;</span><br><span class="line">          int mode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">          if (mode != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">              int height = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">              heightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                      height + mOutsets.top + mOutsets.bottom, mode);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (mOutsets.left &gt; 0 || mOutsets.right &gt; 0) &#123;</span><br><span class="line">          int mode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">          if (mode != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">              int width = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">              widthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                      width + mOutsets.left + mOutsets.right, mode);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">      int width = getMeasuredWidth();</span><br><span class="line">      boolean measure = false;</span><br><span class="line"></span><br><span class="line">      widthMeasureSpec = MeasureSpec.makeMeasureSpec(width, EXACTLY);</span><br><span class="line"></span><br><span class="line">      if (!fixedWidth &amp;&amp; widthMode == AT_MOST) &#123;</span><br><span class="line">          final TypedValue tv = isPortrait ? mWindow.mMinWidthMinor : mWindow.mMinWidthMajor;</span><br><span class="line">          if (tv.type != TypedValue.TYPE_NULL) &#123;</span><br><span class="line">              final int min;</span><br><span class="line">              if (tv.type == TypedValue.TYPE_DIMENSION) &#123;</span><br><span class="line">                  min = (int)tv.getDimension(metrics);</span><br><span class="line">              &#125; else if (tv.type == TypedValue.TYPE_FRACTION) &#123;</span><br><span class="line">                  min = (int)tv.getFraction(mAvailableWidth, mAvailableWidth);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  min = 0;</span><br><span class="line">              &#125;</span><br><span class="line">              if (DEBUG_MEASURE) Log.d(mLogTag, &quot;Adjust for min width: &quot; + min + &quot;, value::&quot;</span><br><span class="line">                      + tv.coerceToString() + &quot;, mAvailableWidth=&quot; + mAvailableWidth);</span><br><span class="line"></span><br><span class="line">              if (width &lt; min) &#123;</span><br><span class="line">                  widthMeasureSpec = MeasureSpec.makeMeasureSpec(min, EXACTLY);</span><br><span class="line">                  measure = true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // TODO: Support height?</span><br><span class="line"></span><br><span class="line">      if (measure) &#123;</span><br><span class="line">          super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>具体的测量的流程在这里就不讲了，主要看一下他整体的调用流程吧，这里又调用了super.onMeasure(widthMeasureSpec, heightMeasureSpec);<br>那么看一下他的父类是怎么实现的  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">       int count = getChildCount();</span><br><span class="line"></span><br><span class="line">       final boolean measureMatchParentChildren =</span><br><span class="line">               MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">               MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">       mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">       int maxHeight = 0;</span><br><span class="line">       int maxWidth = 0;</span><br><span class="line">       int childState = 0;</span><br><span class="line"></span><br><span class="line">       for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">           final View child = getChildAt(i);</span><br><span class="line">           if (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">               measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);</span><br><span class="line">               final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">               maxWidth = Math.max(maxWidth,</span><br><span class="line">                       child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">               maxHeight = Math.max(maxHeight,</span><br><span class="line">                       child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">               childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">               if (measureMatchParentChildren) &#123;</span><br><span class="line">                   if (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                           lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                       mMatchParentChildren.add(child);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Account for padding too</span><br><span class="line">       maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">       maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">       // Check against our minimum height and width</span><br><span class="line">       maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">       // Check against our foreground&apos;s minimum height and width</span><br><span class="line">       final Drawable drawable = getForeground();</span><br><span class="line">       if (drawable != null) &#123;</span><br><span class="line">           maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">           maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">               resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                       childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line"></span><br><span class="line">       count = mMatchParentChildren.size();</span><br><span class="line">       if (count &gt; 1) &#123;</span><br><span class="line">           for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">               final View child = mMatchParentChildren.get(i);</span><br><span class="line">               final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">               final int childWidthMeasureSpec;</span><br><span class="line">               if (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                   final int width = Math.max(0, getMeasuredWidth()</span><br><span class="line">                           - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                           - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                   childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                           width, MeasureSpec.EXACTLY);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                           getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                           lp.leftMargin + lp.rightMargin,</span><br><span class="line">                           lp.width);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final int childHeightMeasureSpec;</span><br><span class="line">               if (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                   final int height = Math.max(0, getMeasuredHeight()</span><br><span class="line">                           - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                           - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                   childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                           height, MeasureSpec.EXACTLY);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                           getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                           lp.topMargin + lp.bottomMargin,</span><br><span class="line">                           lp.height);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里面主要遍历了一下他的子view ,然后调用了子View的measure方法，到这里测量的方法就已经结束了，其他两个方法就不在带大家看了，基本调用都是相同的。<br>到此View的整体显示流程都已经跟大家过了一遍。  </p>
<p>总结一下：  </p>
<p>1.首先在ActivityThread启动Activity OnCreate 方法之前调用的Attach方法，在里面创建了PhoneWindow对象，同时通过Ibinder获取到WMS进行管理PhoneWindow.  </p>
<p>2.在执行OnCreate()方法里的SetContentView()方法时，调用了之前创建PhoneWindow方法里的setContentView方法，在这里面创建了DecorView对象，并且将传入的布局ID，通过LayoutInflate 类进行处理创建反射得到对应View，也就是变量mContentView 。  </p>
<p>3.在ActivityThread执行Activity里的OnResume相关方法时，执行了一个方法makevisible()，里面将之前创建好的DecorView,set到WindowManager,这是一个接口，实现这个接口的是WindowManagerImpl,在这里，又调用了WindowManagerGlobal,这里是一个单例。</p>
<p>4.在WindowManagerGlobal里创建了一个类ViewRootImpl，并且维护这三个链表，分别存放创建的ViewRootImpl,和传进来的View ,还有传进来的相关属性LayoutParams.并且将传进来的View传入到ViewRootImpl 中。  </p>
<p>5.在viewRootImpl 中对view 进行了相关的测量，布局，绘制的操作，最终完成View的显示</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/30/Android-View加载流程分析/" data-id="cjv3l06fo0002dsla1e20aacj" class="article-share-link">Share</a>
      
      
        <a href="/2019/04/30/Android-View加载流程分析/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2019/04/30/Android-View加载流程分析/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-9-0系统启动流程源码分析“" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/30/9-0系统启动流程源码分析“/" class="article-date">
  <time datetime="2019-04-30T02:46:30.000Z" itemprop="datePublished">2019-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/30/9-0系统启动流程源码分析“/">Android 9.0系统Activity启动流程分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这几天终于有时间踏实的看一下Activity 启动流程了，梳理总结一下。先发一下整理的这个流程图，然后咱们按照这个路线进一步分析  </p>
<p><img src="http://ww1.sinaimg.cn/large/007e4h7Uly1g2kh2kj51ej324l12ktej.jpg" alt></p>
<p><strong>首先来看看他的入口在哪</strong><br>Launcher 实际上就是手机上的一个应用程序，点击手机上的一个APP icon，实际上就是LauncherActivity 调用startActivity()然后启动你需要的应用程序。所以咱们通过顺着这条路子查找下去。  </p>
<p><strong>Activity</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void startActivity(Intent intent, @Nullable Bundle options) &#123;</span><br><span class="line">        if (options != null) &#123;</span><br><span class="line">            startActivityForResult(intent, -1, options);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Note we want to go through this call for compatibility with</span><br><span class="line">            // applications that may have overridden the method.</span><br><span class="line">            startActivityForResult(intent, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>最终调用的都是startActivityForResult()方法，默认传入的requestCode 是-1 。咱们接下来看一下这个方法<br><strong>startActivityForResult（）</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,</span><br><span class="line">         @Nullable Bundle options) &#123;</span><br><span class="line">     if (mParent == null) &#123;</span><br><span class="line">         options = transferSpringboardActivityOptions(options);</span><br><span class="line">         Instrumentation.ActivityResult ar =</span><br><span class="line">             mInstrumentation.execStartActivity(</span><br><span class="line">                 this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                 intent, requestCode, options);</span><br><span class="line">         if (ar != null) &#123;</span><br><span class="line">             mMainThread.sendActivityResult(</span><br><span class="line">                 mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                 ar.getResultData());</span><br><span class="line">         &#125;</span><br><span class="line">         if (requestCode &gt;= 0) &#123;</span><br><span class="line">             // If this start is requesting a result, we can avoid making</span><br><span class="line">             // the activity visible until the result is received.  Setting</span><br><span class="line">             // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span><br><span class="line">             // activity hidden during this time, to avoid flickering.</span><br><span class="line">             // This can only be done when a result is requested because</span><br><span class="line">             // that guarantees we will get information back when the</span><br><span class="line">             // activity is finished, no matter what happens to it.</span><br><span class="line">             mStartedActivity = true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         cancelInputsAndStartExitTransition(options);</span><br><span class="line">         // TODO Consider clearing/flushing other event sources and events for child windows.</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         if (options != null) &#123;</span><br><span class="line">             mParent.startActivityFromChild(this, intent, requestCode, options);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             // Note we want to go through this method for compatibility with</span><br><span class="line">             // existing applications that may have overridden it.</span><br><span class="line">             mParent.startActivityFromChild(this, intent, requestCode);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>其他代码不用关心，抓重点，调用Instrumentation这个类的execStartActivity（）方法，然后看一下这个类  </p>
<p><strong>Instrumentation-execStartActivity</strong><br>主要方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        int result = ActivityManager.getService()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                    requestCode, 0, null, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ActivityManager.getService() 通过binder 通信获取ActivityManagerService对象引用,在ActivityManagerService 调用startActivity方法，checkStartActivityResult（）方法是用来做校验检测的，比如activity没有在配置文件里注册等。看一下ams里的startActivity方法调用了startActivityAsUser（）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,</span><br><span class="line">        boolean validateIncomingUser) &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line"></span><br><span class="line">    userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), &quot;startActivityAsUser&quot;);</span><br><span class="line"></span><br><span class="line">    // TODO: Switch to user app stacks here.</span><br><span class="line">    return mActivityStartController.obtainStarter(intent, &quot;startActivityAsUser&quot;)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setMayWait(userId)</span><br><span class="line">            .execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityStartController获取 ActivityStarter对象，执行execute方法，看一下这个方法里面的实现吧  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int execute() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // TODO(b/64750076): Look into passing request directly to these methods to allow</span><br><span class="line">        // for transactional diffs and preprocessing.</span><br><span class="line">        if (mRequest.mayWait) &#123;</span><br><span class="line">            return startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class="line">                    mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class="line">                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class="line">                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class="line">                    mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class="line">                    mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class="line">                    mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class="line">                    mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class="line">                    mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class="line">                    mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        onExecutionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上段代码中我们已经看到mayWait是为true 的因为我们设置了setMayWait(userId)，  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ActivityStarter setMayWait(int userId) &#123;</span><br><span class="line">    mRequest.mayWait = true;</span><br><span class="line">    mRequest.userId = userId;</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以应该走startActivityMayWait（）方法，接下来看看这个方法具体调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private int startActivityMayWait(IApplicationThread caller, int callingUid,</span><br><span class="line">           String callingPackage, Intent intent, String resolvedType,</span><br><span class="line">           IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">           IBinder resultTo, String resultWho, int requestCode, int startFlags,</span><br><span class="line">           ProfilerInfo profilerInfo, WaitResult outResult,</span><br><span class="line">           Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity,</span><br><span class="line">           int userId, TaskRecord inTask, String reason,</span><br><span class="line">           boolean allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">       .............</span><br><span class="line">       .......</span><br><span class="line">       ...</span><br><span class="line">       //解析intent数据</span><br><span class="line">       ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,</span><br><span class="line">               0 /* matchFlags */,</span><br><span class="line">                       computeResolveFilterUid(</span><br><span class="line">                               callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">      ...................</span><br><span class="line">      .......</span><br><span class="line">      </span><br><span class="line">       //收集intent数据到ActivityInfo 对象中.</span><br><span class="line">       ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);</span><br><span class="line"></span><br><span class="line">     ..............</span><br><span class="line">     .........</span><br><span class="line">     .....</span><br><span class="line">           //用于记录Activity数据</span><br><span class="line">           final ActivityRecord[] outRecord = new ActivityRecord[1];</span><br><span class="line">           </span><br><span class="line">           int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,</span><br><span class="line">                   voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                   callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,</span><br><span class="line">                   ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,</span><br><span class="line">                   allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line"></span><br><span class="line">          .......</span><br><span class="line">          ...</span><br><span class="line">          ..</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用startActivity方法，查看该方法源码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">        String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">        SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,</span><br><span class="line">        ActivityRecord[] outActivity, TaskRecord inTask, String reason,</span><br><span class="line">        boolean allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line"></span><br><span class="line">    if (TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Need to specify a reason.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mLastStartReason = reason;</span><br><span class="line">    mLastStartActivityTimeMs = System.currentTimeMillis();</span><br><span class="line">    mLastStartActivityRecord[0] = null;</span><br><span class="line"></span><br><span class="line">    mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">            aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">            callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">            options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">            inTask, allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line"></span><br><span class="line">    if (outActivity != null) &#123;</span><br><span class="line">        // mLastStartActivityRecord[0] is set in the call to startActivity above.</span><br><span class="line">        outActivity[0] = mLastStartActivityRecord[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return getExternalResult(mLastStartActivityResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续往下跟进mLastStartActivityResult = startActivity（…)源码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">            SafeActivityOptions options,</span><br><span class="line">            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,</span><br><span class="line">            TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">        int err = ActivityManager.START_SUCCESS;</span><br><span class="line">        // Pull the optional Ephemeral Installer-only bundle out of the options early.</span><br><span class="line">        final Bundle verificationBundle</span><br><span class="line">                = options != null ? options.popAppVerificationBundle() : null;</span><br><span class="line"></span><br><span class="line">        ProcessRecord callerApp = null;</span><br><span class="line">        if (caller != null) &#123;</span><br><span class="line">            callerApp = mService.getRecordForAppLocked(caller);</span><br><span class="line">            if (callerApp != null) &#123;</span><br><span class="line">                callingPid = callerApp.pid;</span><br><span class="line">                callingUid = callerApp.info.uid;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller</span><br><span class="line">                        + &quot; (pid=&quot; + callingPid + &quot;) when starting: &quot;</span><br><span class="line">                        + intent.toString());</span><br><span class="line">                err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int userId = aInfo != null &amp;&amp; aInfo.applicationInfo != null</span><br><span class="line">                ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;</span><br><span class="line"></span><br><span class="line">        if (err == ActivityManager.START_SUCCESS) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;START u&quot; + userId + &quot; &#123;&quot; + intent.toShortString(true, true, true, false)</span><br><span class="line">                    + &quot;&#125; from uid &quot; + callingUid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ActivityRecord sourceRecord = null;</span><br><span class="line">        ActivityRecord resultRecord = null;</span><br><span class="line">        if (resultTo != null) &#123;</span><br><span class="line">            sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);</span><br><span class="line">            if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                    &quot;Will send result to &quot; + resultTo + &quot; &quot; + sourceRecord);</span><br><span class="line">            if (sourceRecord != null) &#123;</span><br><span class="line">                if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">                    resultRecord = sourceRecord;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int launchFlags = intent.getFlags();</span><br><span class="line">        //通过客户端写入Ibinder 信息传入到ams服务获取到ActivityRecord //对象，里有resultWho，requestCode，launchedFromPackage等。</span><br><span class="line">        if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123;</span><br><span class="line">            // Transfer the result target from the source activity to the new</span><br><span class="line">            // one being started, including any failures.</span><br><span class="line">            if (requestCode &gt;= 0) &#123;</span><br><span class="line">                SafeActivityOptions.abort(options);</span><br><span class="line">                return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;</span><br><span class="line">            &#125;</span><br><span class="line">            resultRecord = sourceRecord.resultTo;</span><br><span class="line">            if (resultRecord != null &amp;&amp; !resultRecord.isInStackLocked()) &#123;</span><br><span class="line">                resultRecord = null;</span><br><span class="line">            &#125;</span><br><span class="line">            resultWho = sourceRecord.resultWho;</span><br><span class="line">            requestCode = sourceRecord.requestCode;</span><br><span class="line">            sourceRecord.resultTo = null;</span><br><span class="line">            if (resultRecord != null) &#123;</span><br><span class="line">                resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">            if (sourceRecord.launchedFromUid == callingUid) &#123;</span><br><span class="line">                // The new activity is being launched from the same uid as the previous</span><br><span class="line">                // activity in the flow, and asking to forward its result back to the</span><br><span class="line">                // previous.  In this case the activity is serving as a trampoline between</span><br><span class="line">                // the two, so we also want to update its launchedFromPackage to be the</span><br><span class="line">                // same as the previous activity.  Note that this is safe, since we know</span><br><span class="line">                // these two packages come from the same uid; the caller could just as</span><br><span class="line">                // well have supplied that same package name itself.  This specifially</span><br><span class="line">                // deals with the case of an intent picker/chooser being launched in the app</span><br><span class="line">                // flow to redirect to an activity picked by the user, where we want the final</span><br><span class="line">                // activity to consider it to have been launched by the previous app activity.</span><br><span class="line">                callingPackage = sourceRecord.launchedFromPackage;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) &#123;</span><br><span class="line">            // We couldn&apos;t find a class that can handle the given Intent.</span><br><span class="line">            // That&apos;s the end of that!</span><br><span class="line">            err = ActivityManager.START_INTENT_NOT_RESOLVED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123;</span><br><span class="line">            // We couldn&apos;t find the specific class specified in the Intent.</span><br><span class="line">            // Also the end of the line.</span><br><span class="line">            err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != null</span><br><span class="line">                &amp;&amp; sourceRecord.getTask().voiceSession != null) &#123;</span><br><span class="line">            // If this activity is being launched as part of a voice session, we need</span><br><span class="line">            // to ensure that it is safe to do so.  If the upcoming activity will also</span><br><span class="line">            // be part of the voice session, we can only launch it if it has explicitly</span><br><span class="line">            // said it supports the VOICE category, or it is a part of the calling app.</span><br><span class="line">            if ((launchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == 0</span><br><span class="line">                    &amp;&amp; sourceRecord.info.applicationInfo.uid != aInfo.applicationInfo.uid) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    intent.addCategory(Intent.CATEGORY_VOICE);</span><br><span class="line">                    if (!mService.getPackageManager().activitySupportsIntent(</span><br><span class="line">                            intent.getComponent(), intent, resolvedType)) &#123;</span><br><span class="line">                        Slog.w(TAG,</span><br><span class="line">                                &quot;Activity being started in current voice task does not support voice: &quot;</span><br><span class="line">                                        + intent);</span><br><span class="line">                        err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);</span><br><span class="line">                    err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != null) &#123;</span><br><span class="line">            // If the caller is starting a new voice session, just make sure the target</span><br><span class="line">            // is actually allowing it to run this way.</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!mService.getPackageManager().activitySupportsIntent(intent.getComponent(),</span><br><span class="line">                        intent, resolvedType)) &#123;</span><br><span class="line">                    Slog.w(TAG,</span><br><span class="line">                            &quot;Activity being started in new voice task does not support: &quot;</span><br><span class="line">                                    + intent);</span><br><span class="line">                    err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);</span><br><span class="line">                err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getStack();</span><br><span class="line"></span><br><span class="line">        if (err != START_SUCCESS) &#123;</span><br><span class="line">            if (resultRecord != null) &#123;</span><br><span class="line">                resultStack.sendActivityResultLocked(</span><br><span class="line">                        -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null);</span><br><span class="line">            &#125;</span><br><span class="line">            SafeActivityOptions.abort(options);</span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line">            //权限检测</span><br><span class="line">        boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,</span><br><span class="line">                requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity,</span><br><span class="line">                inTask != null, callerApp, resultRecord, resultStack);</span><br><span class="line">        abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,</span><br><span class="line">                callingPid, resolvedType, aInfo.applicationInfo);</span><br><span class="line">        .............</span><br><span class="line">        ........</span><br><span class="line">        .</span><br><span class="line">        //把将要启动的Activity的相关信息保存在变量r中</span><br><span class="line">        ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">                callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),</span><br><span class="line">                resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null,</span><br><span class="line">                mSupervisor, checkedOptions, sourceRecord);</span><br><span class="line">        if (outActivity != null) &#123;</span><br><span class="line">            outActivity[0] = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     ...........</span><br><span class="line">     .........</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">        return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">                true /* doResume */, checkedOptions, inTask, outActivity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来继续跟进startActivity方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">             IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">             int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">             ActivityRecord[] outActivity) &#123;</span><br><span class="line">     int result = START_CANCELED;</span><br><span class="line">     try &#123;</span><br><span class="line">         mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">         result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                 startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         // If we are not able to proceed, disassociate the activity from the task. Leaving an</span><br><span class="line">         // activity in an incomplete state can lead to issues, such as performing operations</span><br><span class="line">         // without a window container.</span><br><span class="line">         final ActivityStack stack = mStartActivity.getStack();</span><br><span class="line">         if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; stack != null) &#123;</span><br><span class="line">             stack.finishActivityLocked(mStartActivity, RESULT_CANCELED,</span><br><span class="line">                     null /* intentResultData */, &quot;startActivity&quot;, true /* oomAdj */);</span><br><span class="line">         &#125;</span><br><span class="line">         mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     postStartActivityProcessing(r, result, mTargetStack);</span><br><span class="line"></span><br><span class="line">     return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>查找重点代码继续跟进 result = startActivityUnchecked(r….  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// Note: This method should only be called from &#123;@link startActivity&#125;.</span><br><span class="line">   private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">           IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">           int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">           ActivityRecord[] outActivity) &#123;</span><br><span class="line"></span><br><span class="line">       setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">               voiceInteractor);</span><br><span class="line">       //计算启动模式launchMode</span><br><span class="line">       computeLaunchingTaskFlags();</span><br><span class="line">       </span><br><span class="line">       computeSourceStack();</span><br><span class="line"></span><br><span class="line">       mIntent.setFlags(mLaunchFlags);</span><br><span class="line"></span><br><span class="line">       ActivityRecord reusedActivity = getReusableIntentActivity();</span><br><span class="line"></span><br><span class="line">       int preferredWindowingMode = WINDOWING_MODE_UNDEFINED;</span><br><span class="line">       int preferredLaunchDisplayId = DEFAULT_DISPLAY;</span><br><span class="line">       if (mOptions != null) &#123;</span><br><span class="line">           preferredWindowingMode = mOptions.getLaunchWindowingMode();</span><br><span class="line">           preferredLaunchDisplayId = mOptions.getLaunchDisplayId();</span><br><span class="line">       &#125;</span><br><span class="line">      ..............</span><br><span class="line">      ..........</span><br><span class="line">      ....</span><br><span class="line">      </span><br><span class="line">               mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                       mOptions);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else if (mStartActivity != null) &#123;</span><br><span class="line">           mSupervisor.mRecentTasks.add(mStartActivity.getTask());</span><br><span class="line">       &#125;</span><br><span class="line">       mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack);</span><br><span class="line"></span><br><span class="line">       mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(), preferredWindowingMode,</span><br><span class="line">               preferredLaunchDisplayId, mTargetStack);</span><br><span class="line"></span><br><span class="line">       return START_SUCCESS;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 经过处理启动模式，是否添加新栈等一系列操作后最终调用mSupervisor.resumeFocusedStackTopActivityLocke方法<br> 查看 ActivityStackSupervisor里的方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line"></span><br><span class="line">    if (!readyToResume()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    if (r == null || !r.isState(RESUMED)) &#123;</span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(null, null);</span><br><span class="line">    &#125; else if (r.isState(RESUMED)) &#123;</span><br><span class="line">        // Kick off any lingering app transitions form the MoveTaskToFront operation.</span><br><span class="line">        mFocusedStack.executeAppTransition(targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进ActivityStack类里的resumeTopActivityUncheckedLocked方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">       if (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">           // Don&apos;t even start recursing.</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       boolean result = false;</span><br><span class="line">       try &#123;</span><br><span class="line">           // Protect against recursion.</span><br><span class="line">           mStackSupervisor.inResumeTopActivity = true;</span><br><span class="line">           result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">           // When resuming the top activity, it may be necessary to pause the top activity (for</span><br><span class="line">           // example, returning to the lock screen. We suppress the normal pause logic in</span><br><span class="line">           // &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the</span><br><span class="line">           // end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here</span><br><span class="line">           // to ensure any necessary pause logic occurs. In the case where the Activity will be</span><br><span class="line">           // shown regardless of the lock screen, the call to</span><br><span class="line">           // &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped.</span><br><span class="line">           final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);</span><br><span class="line">           if (next == null || !next.canTurnScreenOn()) &#123;</span><br><span class="line">               checkReadyForSleep();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           mStackSupervisor.inResumeTopActivity = false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>查看resumeTopActivityInnerLocked（）方法源码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">        if (!mService.mBooting &amp;&amp; !mService.mBooted) &#123;</span><br><span class="line">            // Not ready yet!</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Find the next top-most activity to resume in this stack that is not finishing and is</span><br><span class="line">        // focusable. If it is not focusable, we will fall into the case below to resume the</span><br><span class="line">        // top activity in the next focusable task.</span><br><span class="line">        final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">        boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false);</span><br><span class="line">        if (mResumedActivity != null) &#123;</span><br><span class="line">            if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                    &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</span><br><span class="line">            pausing |= startPausingLocked(userLeaving, false, next, false);</span><br><span class="line">        &#125;</span><br><span class="line">        if (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class="line">            if (DEBUG_SWITCH || DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                    &quot;resumeTopActivityLocked: Skip resume: need to start pausing&quot;);</span><br><span class="line">            // At this point we want to put the upcoming activity&apos;s process</span><br><span class="line">            // at the top of the LRU list, since we know we will be needing it</span><br><span class="line">            // very soon and it would be a waste to let it get killed if it</span><br><span class="line">            // happens to be sitting towards the end.</span><br><span class="line">            if (next.app != null &amp;&amp; next.app.thread != null) &#123;</span><br><span class="line">                mService.updateLruProcessLocked(next.app, true, null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            if (lastResumed != null) &#123;</span><br><span class="line">                lastResumed.setWillCloseOrEnterPip(true);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">                &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line">            // It is possible for the activity to be resumed when we paused back stacks above if the</span><br><span class="line">            // next activity doesn&apos;t have to wait for pause to complete.</span><br><span class="line">            // So, nothing else to-do except:</span><br><span class="line">            // Make sure we have executed any pending transitions, since there</span><br><span class="line">            // should be nothing left to do at this point.</span><br><span class="line">            executeAppTransition(options);</span><br><span class="line">            if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                    &quot;resumeTopActivityLocked: Top activity resumed (dontWaitForPause) &quot; + next);</span><br><span class="line">            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">                    .......</span><br><span class="line">                    //注释2</span><br><span class="line">                    mStackSupervisor.startSpecificActivityLocked(next, true, false);</span><br><span class="line">                    if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       ......</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从这里的源码可以看到当启动新的activity的时候,上一个activity走完onPause,之后才可以走新activity:onCreate —&gt;onStart—&gt;onResume…<br>接着看注释2:回调过程重新交给ActivityStackSupervisor的startSpecificActivityLocked;  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">            boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">        // Is this activity&apos;s application already running?</span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, true);</span><br><span class="line"></span><br><span class="line">        getLaunchTimeTracker().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">        if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0</span><br><span class="line">                        || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                    // Don&apos;t add this if it is a platform component that is marked</span><br><span class="line">                    // to run in multiple processes, because this is actually</span><br><span class="line">                    // part of the framework so doesn&apos;t make sense to track as a</span><br><span class="line">                    // separate apk in the process.</span><br><span class="line">                    app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,</span><br><span class="line">                            mService.mProcessStats);</span><br><span class="line">                &#125;</span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If a dead object exception was thrown -- fall through to</span><br><span class="line">            // restart the application.</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">                &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>判断当前是否已有进程，如果已经有了就realStartActivityLocked启动Activity,如果没有开启进程。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">          boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">                // Create activity launch transaction.</span><br><span class="line">                .............. </span><br><span class="line">                ............</span><br><span class="line">                ........</span><br><span class="line">                //核心代码重点关注</span><br><span class="line">              final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">                      r.appToken);</span><br><span class="line">              clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),</span><br><span class="line">                      System.identityHashCode(r), r.info,</span><br><span class="line">                      // TODO: Have this take the merged configuration instead of separate global</span><br><span class="line">                      // and override configs.</span><br><span class="line">                      mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                      mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                      r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                      r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">                      profilerInfo));</span><br><span class="line"></span><br><span class="line">              // Set desired final state.</span><br><span class="line">              final ActivityLifecycleItem lifecycleItem;</span><br><span class="line">              if (andResume) &#123;</span><br><span class="line">                  lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">              &#125;</span><br><span class="line">              clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line">             mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          ..............</span><br><span class="line">          ...........</span><br><span class="line">          ......</span><br><span class="line">          .</span><br></pre></td></tr></table></figure>
<p>通过事务进行启动，区别8.0系统源码，8.0直接通过ActivityThread进行启动，9.0通过事务进行启动。ActivityManagerService 获取ClientLifecycleManager对象调用里么的scheduleTransaction方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">    final IApplicationThread client = transaction.getClient();</span><br><span class="line">    transaction.schedule();</span><br><span class="line">    if (!(client instanceof Binder)) &#123;</span><br><span class="line">        // If client is not an instance of Binder - it&apos;s a remote call and at this point it is</span><br><span class="line">        // safe to recycle the object. All objects used for local calls will be recycled after</span><br><span class="line">        // the transaction is executed on client in ActivityThread.</span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上看可以看出来最终调用的是ClientTransaction类的schedule（）方法，那么在看里面的代码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void schedule() throws RemoteException &#123;</span><br><span class="line">     mClient.scheduleTransaction(this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>mClient实际是IApplicationThread，那么谁来实现了这个IApplicationThread了呢？答案就是ActivityThread 里的内部类ApplicationThread  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">       public void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">           ActivityThread.this.scheduleTransaction(transaction);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用的是ActivityThread类里的scheduleTransaction方法，看一下当前类里并没有实现该方法，那他是在哪里调用的，答案就是他的父类，他继承ClientTransactionHandler ，那就看一下他父类是怎么实现的吧。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTransaction(ClientTransaction transaction) &#123;</span><br><span class="line">        transaction.preExecute(this);</span><br><span class="line">        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用用sendMessage这个方法，这个方法在父类是个抽象类，那么看看他的子类如何实现的  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">     if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">         TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">         + &quot;: &quot; + arg1 + &quot; / &quot; + obj);</span><br><span class="line">     Message msg = Message.obtain();</span><br><span class="line">     msg.what = what;</span><br><span class="line">     msg.obj = obj;</span><br><span class="line">     msg.arg1 = arg1;</span><br><span class="line">     msg.arg2 = arg2;</span><br><span class="line">     if (async) &#123;</span><br><span class="line">         msg.setAsynchronous(true);</span><br><span class="line">     &#125;</span><br><span class="line">     mH.sendMessage(msg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>最终是通过handler发送一个消息，那么看看他接受的地方是如何处理的。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case EXECUTE_TRANSACTION:</span><br><span class="line">                   final ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">                   mTransactionExecutor.execute(transaction);</span><br><span class="line">                   if (isSystem()) &#123;</span><br><span class="line">                       // Client transactions inside system process are recycled on the client side</span><br><span class="line">                       // instead of ClientLifecycleManager to avoid being cleared before this</span><br><span class="line">                       // message is handled.</span><br><span class="line">                       transaction.recycle();</span><br><span class="line">                   &#125;</span><br><span class="line">                   // TODO(lifecycler): Recycle locally scheduled transactions.</span><br><span class="line">                   break;</span><br></pre></td></tr></table></figure>
<p>TransactionExecutor 这又是什么鬼，不管了，往下看看他具体实现的时候那么看一下这个类是怎么实现的execute方法呢？  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void execute(ClientTransaction transaction) &#123;</span><br><span class="line">      final IBinder token = transaction.getActivityToken();</span><br><span class="line">      log(&quot;Start resolving transaction for client: &quot; + mTransactionHandler + &quot;, token: &quot; + token);</span><br><span class="line"></span><br><span class="line">      executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">      executeLifecycleState(transaction);</span><br><span class="line">      mPendingActions.clear();</span><br><span class="line">      log(&quot;End resolving transaction&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void executeLifecycleState(ClientTransaction transaction) &#123;</span><br><span class="line">    final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">    if (lifecycleItem == null) &#123;</span><br><span class="line">        // No lifecycle request, return early.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;Resolving lifecycle state: &quot; + lifecycleItem);</span><br><span class="line"></span><br><span class="line">    final IBinder token = transaction.getActivityToken();</span><br><span class="line">    final ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    if (r == null) &#123;</span><br><span class="line">        // Ignore requests for non-existent client records for now.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Cycle to the state right before the final requested state.</span><br><span class="line">    cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */);</span><br><span class="line"></span><br><span class="line">    // Execute the final transition with proper parameters.</span><br><span class="line">    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用executeLifecycleState这个方法里的lifecycleItem.execute，那么lifecycleItem这个类是什么时候传进来的呢，穿越回去看一下这个代码 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">                        r.appToken);</span><br><span class="line">                clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),</span><br><span class="line">                        System.identityHashCode(r), r.info,</span><br><span class="line">                        // TODO: Have this take the merged configuration instead of separate global</span><br><span class="line">                        // and override configs.</span><br><span class="line">                        mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                        mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                        r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">                        profilerInfo));</span><br></pre></td></tr></table></figure>
<p>LaunchActivityItem.obtain(new Intent(r.intent)就是在这里创建的，LaunchActivityItem看一里面的execute源码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void execute(ClientTransactionHandler client, IBinder token,</span><br><span class="line">        PendingTransactionActions pendingActions) &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">    ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client);</span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, null /* customIntent */);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终实现的是ClientTransactionHandler这个类的handleLaunchActivity方法，那么谁实现了这个类呢，答案就是ActivityThread,那么看一下这个方法吧  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public Activity handleLaunchActivity(ActivityClientRecord r,</span><br><span class="line">           PendingTransactionActions pendingActions, Intent customIntent) &#123;</span><br><span class="line">       // If we are getting ready to gc after going to the background, well</span><br><span class="line">       // we are back active so skip it.</span><br><span class="line">       unscheduleGcIdler();</span><br><span class="line">       mSomeActivitiesChanged = true;</span><br><span class="line"></span><br><span class="line">       if (r.profilerInfo != null) &#123;</span><br><span class="line">           mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">           mProfiler.startProfiling();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Make sure we are running with the most recent config.</span><br><span class="line">       handleConfigurationChanged(null, null);</span><br><span class="line"></span><br><span class="line">       if (localLOGV) Slog.v(</span><br><span class="line">           TAG, &quot;Handling launch of &quot; + r);</span><br><span class="line"></span><br><span class="line">       // Initialize before creating the activity</span><br><span class="line">       if (!ThreadedRenderer.sRendererDisabled) &#123;</span><br><span class="line">           GraphicsEnvironment.earlyInitEGL();</span><br><span class="line">       &#125;</span><br><span class="line">       WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">       final Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">       ..................</span><br><span class="line">       ..............</span><br><span class="line">       ........</span><br><span class="line">       .</span><br><span class="line">               </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>重点看一下这个performLaunchActivity这个方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">/**  Core implementation of activity launch. */</span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    if (r.packageInfo == null) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    if (component == null) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.activityInfo.targetActivity != null) &#123;</span><br><span class="line">        component = new ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建上下文</span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = null;</span><br><span class="line">    //注释1</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        if (r.state != null) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //注释2</span><br><span class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);</span><br><span class="line">        if (localLOGV) Slog.v(</span><br><span class="line">                TAG, r + &quot;: app=&quot; + app</span><br><span class="line">                + &quot;, appName=&quot; + app.getPackageName()</span><br><span class="line">                + &quot;, pkg=&quot; + r.packageInfo.getPackageName()</span><br><span class="line">                + &quot;, comp=&quot; + r.intent.getComponent().toShortString()</span><br><span class="line">                + &quot;, dir=&quot; + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = new Configuration(mCompatConfiguration);</span><br><span class="line">            if (r.overrideConfig != null) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</span><br><span class="line">                    + r.activityInfo.name + &quot; with config &quot; + config);</span><br><span class="line">            Window window = null;</span><br><span class="line">            if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = null;</span><br><span class="line">                r.mPendingRemoveWindowManager = null;</span><br><span class="line">            &#125;</span><br><span class="line">            appContext.setOuterContext(activity);</span><br><span class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">            if (customIntent != null) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = null;</span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            activity.mStartedActivity = false;</span><br><span class="line">            int theme = r.activityInfo.getThemeResource();</span><br><span class="line">            if (theme != 0) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = false;</span><br><span class="line">            //注释3</span><br><span class="line">            if (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!activity.mCalled) &#123;</span><br><span class="line">                throw new SuperNotCalledException(</span><br><span class="line">                    &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                    &quot; did not call through to super.onCreate()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">        &#125;</span><br><span class="line">        r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to start activity &quot; + component</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点分析这三个注释，注释1，就很简单了，就是创建了一个Activity对象，注释2就是创建application，看看里么具体的代码吧  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">        Instrumentation instrumentation) &#123;</span><br><span class="line">    if (mApplication != null) &#123;</span><br><span class="line">        return mApplication;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;makeApplication&quot;);</span><br><span class="line"></span><br><span class="line">    Application app = null;</span><br><span class="line"></span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">        appClass = &quot;android.app.Application&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                    &quot;initializeJavaContextClassLoader&quot;);</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate application &quot; + appClass</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActivityThread.mAllApplications.add(app);</span><br><span class="line">    mApplication = app;</span><br><span class="line"></span><br><span class="line">    if (instrumentation != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            instrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Rewrite the R &apos;constants&apos; for all library apks.</span><br><span class="line">    SparseArray&lt;String&gt; packageIdentifiers = getAssets().getAssignedPackageIdentifiers();</span><br><span class="line">    final int N = packageIdentifiers.size();</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        final int id = packageIdentifiers.keyAt(i);</span><br><span class="line">        if (id == 0x01 || id == 0x7f) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前已有application，就直接return，否则创建application，然后重点看这个代码instrumentation.callApplicationOnCreate(app)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void callApplicationOnCreate(Application app) &#123;</span><br><span class="line">     app.onCreate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>呵呵哒，终于看到曙光了，终于看到咱们application里的onCreate 方法了。在回过头看一下注释3是什么鬼东西，同样是 这个类Instrumentation </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">     prePerformCreate(activity);</span><br><span class="line">     activity.performCreate(icicle);</span><br><span class="line">     postPerformCreate(activity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>然后看一下activity.performCreate(icicle)这个方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123;</span><br><span class="line">    mCanEnterPictureInPicture = true;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    if (persistentState != null) &#123;</span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">    &#125;</span><br><span class="line">    writeEventLog(LOG_AM_ON_CREATE_CALLED, &quot;performCreate&quot;);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line"></span><br><span class="line">    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">            com.android.internal.R.styleable.Window_windowNoDisplay, false);</span><br><span class="line">    mFragments.dispatchActivityCreated();</span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>呵呵哒Activity 的onCreate 方法也出来了。这就知道了为什么先执行application oncreate 了吧。那么到这里，Activity 启动就全部讲完了，但是还没有结束，还有断，就是当前进程没有开启的时候，当前点击桌面icon的时候，那个分支还没有讲，那接下来咱们就看一下这个吧，方便大家回忆，我在把之前的代码贴出来看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">            boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">        // Is this activity&apos;s application already running?</span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, true);</span><br><span class="line"></span><br><span class="line">        getLaunchTimeTracker().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">        if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0</span><br><span class="line">                        || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                    // Don&apos;t add this if it is a platform component that is marked</span><br><span class="line">                    // to run in multiple processes, because this is actually</span><br><span class="line">                    // part of the framework so doesn&apos;t make sense to track as a</span><br><span class="line">                    // separate apk in the process.</span><br><span class="line">                    app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,</span><br><span class="line">                            mService.mProcessStats);</span><br><span class="line">                &#125;</span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If a dead object exception was thrown -- fall through to</span><br><span class="line">            // restart the application.</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">                &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>mService.startProcessLocked ，也就是通过ActivityManagerService,咱们继续跟  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line">   final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,</span><br><span class="line">           boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,</span><br><span class="line">           boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,</span><br><span class="line">           String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123;</span><br><span class="line">       long startTime = SystemClock.elapsedRealtime();</span><br><span class="line">       ProcessRecord app;</span><br><span class="line">       if (!isolated) &#123;</span><br><span class="line">           app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line">           checkTime(startTime, &quot;startProcess: after getProcessRecord&quot;);</span><br><span class="line"></span><br><span class="line">           if ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) != 0) &#123;</span><br><span class="line">               // If we are in the background, then check to see if this process</span><br><span class="line">               // is bad.  If so, we will just silently fail.</span><br><span class="line">               if (mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                   if (DEBUG_PROCESSES) Slog.v(TAG, &quot;Bad process: &quot; + info.uid</span><br><span class="line">                           + &quot;/&quot; + info.processName);</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // When the user is explicitly starting a process, then clear its</span><br><span class="line">               // crash count so that we won&apos;t make it bad until they see at</span><br><span class="line">               // least one crash dialog again, and make the process good again</span><br><span class="line">               // if it had been bad.</span><br><span class="line">               if (DEBUG_PROCESSES) Slog.v(TAG, &quot;Clearing bad process: &quot; + info.uid</span><br><span class="line">                       + &quot;/&quot; + info.processName);</span><br><span class="line">               mAppErrors.resetProcessCrashTimeLocked(info);</span><br><span class="line">               if (mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                   EventLog.writeEvent(EventLogTags.AM_PROC_GOOD,</span><br><span class="line">                           UserHandle.getUserId(info.uid), info.uid,</span><br><span class="line">                           info.processName);</span><br><span class="line">                   mAppErrors.clearBadProcessLocked(info);</span><br><span class="line">                   if (app != null) &#123;</span><br><span class="line">                       app.bad = false;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // If this is an isolated process, it can&apos;t re-use an existing process.</span><br><span class="line">           app = null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // We don&apos;t have to do anything more if:</span><br><span class="line">       // (1) There is an existing application record; and</span><br><span class="line">       // (2) The caller doesn&apos;t think it is dead, OR there is no thread</span><br><span class="line">       //     object attached to it so we know it couldn&apos;t have crashed; and</span><br><span class="line">       // (3) There is a pid assigned to it, so it is either starting or</span><br><span class="line">       //     already running.</span><br><span class="line">       if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, &quot;startProcess: name=&quot; + processName</span><br><span class="line">               + &quot; app=&quot; + app + &quot; knownToBeDead=&quot; + knownToBeDead</span><br><span class="line">               + &quot; thread=&quot; + (app != null ? app.thread : null)</span><br><span class="line">               + &quot; pid=&quot; + (app != null ? app.pid : -1));</span><br><span class="line">       if (app != null &amp;&amp; app.pid &gt; 0) &#123;</span><br><span class="line">           if ((!knownToBeDead &amp;&amp; !app.killed) || app.thread == null) &#123;</span><br><span class="line">               // We already have the app running, or are waiting for it to</span><br><span class="line">               // come up (we have a pid but not yet its thread), so keep it.</span><br><span class="line">               if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, &quot;App already running: &quot; + app);</span><br><span class="line">               // If this is a new package in the process, add the package to the list</span><br><span class="line">               app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">               checkTime(startTime, &quot;startProcess: done, added package to proc&quot;);</span><br><span class="line">               return app;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // An application record is attached to a previous process,</span><br><span class="line">           // clean it up now.</span><br><span class="line">           if (DEBUG_PROCESSES || DEBUG_CLEANUP) Slog.v(TAG_PROCESSES, &quot;App died: &quot; + app);</span><br><span class="line">           checkTime(startTime, &quot;startProcess: bad proc running, killing&quot;);</span><br><span class="line">           killProcessGroup(app.uid, app.pid);</span><br><span class="line">           handleAppDiedLocked(app, true, true);</span><br><span class="line">           checkTime(startTime, &quot;startProcess: done killing old proc&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       String hostingNameStr = hostingName != null</span><br><span class="line">               ? hostingName.flattenToShortString() : null;</span><br><span class="line"></span><br><span class="line">       if (app == null) &#123;</span><br><span class="line">           checkTime(startTime, &quot;startProcess: creating new process record&quot;);</span><br><span class="line">           app = newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">           if (app == null) &#123;</span><br><span class="line">               Slog.w(TAG, &quot;Failed making new process record for &quot;</span><br><span class="line">                       + processName + &quot;/&quot; + info.uid + &quot; isolated=&quot; + isolated);</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">           app.crashHandler = crashHandler;</span><br><span class="line">           app.isolatedEntryPoint = entryPoint;</span><br><span class="line">           app.isolatedEntryPointArgs = entryPointArgs;</span><br><span class="line">           checkTime(startTime, &quot;startProcess: done creating new process record&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // If this is a new package in the process, add the package to the list</span><br><span class="line">           app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">           checkTime(startTime, &quot;startProcess: added package to existing proc&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // If the system is not ready yet, then hold off on starting this</span><br><span class="line">       // process until it is.</span><br><span class="line">       if (!mProcessesReady</span><br><span class="line">               &amp;&amp; !isAllowedWhileBooting(info)</span><br><span class="line">               &amp;&amp; !allowWhileBooting) &#123;</span><br><span class="line">           if (!mProcessesOnHold.contains(app)) &#123;</span><br><span class="line">               mProcessesOnHold.add(app);</span><br><span class="line">           &#125;</span><br><span class="line">           if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES,</span><br><span class="line">                   &quot;System not ready, putting on hold: &quot; + app);</span><br><span class="line">           checkTime(startTime, &quot;startProcess: returning with proc on hold&quot;);</span><br><span class="line">           return app;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       checkTime(startTime, &quot;startProcess: stepping in to startProcess&quot;);</span><br><span class="line">       final boolean success = startProcessLocked(app, hostingType, hostingNameStr, abiOverride);</span><br><span class="line">       checkTime(startTime, &quot;startProcess: done starting proc!&quot;);</span><br><span class="line">       return success ? app : null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line"> private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint,</span><br><span class="line">         ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,</span><br><span class="line">         String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span><br><span class="line">         long startTime) &#123;</span><br><span class="line">     app.pendingStart = true;</span><br><span class="line">     app.killedByAm = false;</span><br><span class="line">     app.removed = false;</span><br><span class="line">     app.killed = false;</span><br><span class="line">     final long startSeq = app.startSeq = ++mProcStartSeqCounter;</span><br><span class="line">     app.setStartParams(uid, hostingType, hostingNameStr, seInfo, startTime);</span><br><span class="line">     if (mConstants.FLAG_PROCESS_START_ASYNC) &#123;</span><br><span class="line">         if (DEBUG_PROCESSES) Slog.i(TAG_PROCESSES,</span><br><span class="line">                 &quot;Posting procStart msg for &quot; + app.toShortString());</span><br><span class="line">         mProcStartHandler.post(() -&gt; &#123;</span><br><span class="line">             try &#123;</span><br><span class="line">                 synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                     final String reason = isProcStartValidLocked(app, startSeq);</span><br><span class="line">                     if (reason != null) &#123;</span><br><span class="line">                         Slog.w(TAG_PROCESSES, app + &quot; not valid anymore,&quot;</span><br><span class="line">                                 + &quot; don&apos;t start process, &quot; + reason);</span><br><span class="line">                         app.pendingStart = false;</span><br><span class="line">                         return;</span><br><span class="line">                     &#125;</span><br><span class="line">                     app.usingWrapper = invokeWith != null</span><br><span class="line">                             || SystemProperties.get(&quot;wrap.&quot; + app.processName) != null;</span><br><span class="line">                     mPendingStarts.put(startSeq, app);</span><br><span class="line">                 &#125;</span><br><span class="line">                 final ProcessStartResult startResult = startProcess(app.hostingType, entryPoint,</span><br><span class="line">                         app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo,</span><br><span class="line">                         requiredAbi, instructionSet, invokeWith, app.startTime);</span><br><span class="line">                 synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                     handleProcessStartedLocked(app, startResult, startSeq);</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用startProcess这个方法看看这个方法里面怎么实现  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private ProcessStartResult startProcess(String hostingType, String entryPoint,</span><br><span class="line">        ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,</span><br><span class="line">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span><br><span class="line">        long startTime) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; +</span><br><span class="line">                app.processName);</span><br><span class="line">        checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</span><br><span class="line">        final ProcessStartResult startResult;</span><br><span class="line">        if (hostingType.equals(&quot;webview_service&quot;)) &#123;</span><br><span class="line">            startResult = startWebView(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, null,</span><br><span class="line">                    new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, invokeWith,</span><br><span class="line">                    new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        checkTime(startTime, &quot;startProcess: returned from zygote!&quot;);</span><br><span class="line">        return startResult;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点在这里Process.start（）看一下Process 这个类吧  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static final ProcessStartResult start(final String processClass,</span><br><span class="line">                               final String niceName,</span><br><span class="line">                               int uid, int gid, int[] gids,</span><br><span class="line">                               int runtimeFlags, int mountExternal,</span><br><span class="line">                               int targetSdkVersion,</span><br><span class="line">                               String seInfo,</span><br><span class="line">                               String abi,</span><br><span class="line">                               String instructionSet,</span><br><span class="line">                               String appDataDir,</span><br><span class="line">                               String invokeWith,</span><br><span class="line">                               String[] zygoteArgs) &#123;</span><br><span class="line">     return zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                 runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                 abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>看到zygote就明白了往下就不继续跟了太长了，实际就是通过zygote force一个进程，每个应用程序都是通过zygote force 的进程。进程创建之后那就应该走这个应用程序的Main方法了，别忘了android 是用Java写的，所以入口就是Main（）方法咯。也就是ActivityThread中的Main方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line"></span><br><span class="line">        // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">        // disable it here, but selectively enable it later (via</span><br><span class="line">        // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">        CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        // Set the reporter for event logging in libcore</span><br><span class="line">        EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">        // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span><br><span class="line">        // It will be in the format &quot;seq=114&quot;</span><br><span class="line">        long startSeq = 0;</span><br><span class="line">        if (args != null) &#123;</span><br><span class="line">            for (int i = args.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">                if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                    startSeq = Long.parseLong(</span><br><span class="line">                            args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // End of event ActivityThreadMain.</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在mian方法里创建了looper，还有创建了一个ActivityThread 对象，之前一直以为ActivityThread是主线程，但是看源码发现它并不是一个线程，只是一个对象，其实咱们所的主线程就是整个进程的线程，那么往下看thread.attach(false, startSeq);   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void attach(boolean system, long startSeq) &#123;</span><br><span class="line">        sCurrentActivityThread = this;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        if (!system) &#123;</span><br><span class="line">            ViewRootImpl.addFirstDrawHandler(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    ensureJitEnabled();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,</span><br><span class="line">                                                    UserHandle.myUserId());</span><br><span class="line">            //重点看一下这里注释1</span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            final IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            try &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当前传入的是false 所以重点看一下注释1，注释1主要是通过IBinder获取到AMS，这里就简写了。通过AMS调用attachApplication，咱们重点在看这里  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public final void attachApplication(IApplicationThread thread, long startSeq) &#123;</span><br><span class="line">     synchronized (this) &#123;</span><br><span class="line">         int callingPid = Binder.getCallingPid();</span><br><span class="line">         final int callingUid = Binder.getCallingUid();</span><br><span class="line">         final long origId = Binder.clearCallingIdentity();</span><br><span class="line">         attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">         Binder.restoreCallingIdentity(origId);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在看一下这个方法attachApplicationLocked（）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line">    private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">            int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">                关键代码</span><br><span class="line">                else if (app.instr != null) &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                        app.instr.mClass,</span><br><span class="line">                        profilerInfo, app.instr.mArguments,</span><br><span class="line">                        app.instr.mWatcher,</span><br><span class="line">                        app.instr.mUiAutomationConnection, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers, null, profilerInfo,</span><br><span class="line">                        null, null, null, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>thread.bindApplication这里调用ActivityThread里的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">            List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">            ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">            IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">            IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">            boolean enableBinderTracking, boolean trackAllocation,</span><br><span class="line">            boolean isRestrictedBackupMode, boolean persistent, Configuration config,</span><br><span class="line">            CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span><br><span class="line">            String buildSerial, boolean autofillCompatibilityEnabled) &#123;</span><br><span class="line"></span><br><span class="line">        if (services != null) &#123;</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                // Test code to make sure the app could see the passed-in services.</span><br><span class="line">                for (Object oname : services.keySet()) &#123;</span><br><span class="line">                    if (services.get(oname) == null) &#123;</span><br><span class="line">                        continue; // AM just passed in a null service.</span><br><span class="line">                    &#125;</span><br><span class="line">                    String name = (String) oname;</span><br><span class="line"></span><br><span class="line">                    // See b/79378449 about the following exemption.</span><br><span class="line">                    switch (name) &#123;</span><br><span class="line">                        case &quot;package&quot;:</span><br><span class="line">                        case Context.WINDOW_SERVICE:</span><br><span class="line">                            continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (ServiceManager.getService(name) == null) &#123;</span><br><span class="line">                        Log.wtf(TAG, &quot;Service &quot; + name + &quot; should be accessible by this app&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Setup the service cache in the ServiceManager</span><br><span class="line">            ServiceManager.initServiceCache(services);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">        AppBindData data = new AppBindData();</span><br><span class="line">        data.processName = processName;</span><br><span class="line">        data.appInfo = appInfo;</span><br><span class="line">        data.providers = providers;</span><br><span class="line">        data.instrumentationName = instrumentationName;</span><br><span class="line">        data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">        data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">        data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">        data.debugMode = debugMode;</span><br><span class="line">        data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">        data.trackAllocation = trackAllocation;</span><br><span class="line">        data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">        data.persistent = persistent;</span><br><span class="line">        data.config = config;</span><br><span class="line">        data.compatInfo = compatInfo;</span><br><span class="line">        data.initProfilerInfo = profilerInfo;</span><br><span class="line">        data.buildSerial = buildSerial;</span><br><span class="line">        data.autofillCompatibilityEnabled = autofillCompatibilityEnabled;</span><br><span class="line">        sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看看吧sendMessage是不是很熟悉，咱们看看接收后怎么处理  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case BIND_APPLICATION:</span><br><span class="line">                 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">                 AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                 handleBindApplication(data);</span><br><span class="line">                 Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                 break;</span><br></pre></td></tr></table></figure>
<p>看看这个方法handleBindApplication  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    核心重点代码 </span><br><span class="line"></span><br><span class="line">     final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);</span><br><span class="line">    updateLocaleListFromAppContext(appContext,</span><br><span class="line">            mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Continue loading instrumentation.</span><br><span class="line">    if (ii != null) &#123;</span><br><span class="line">        ApplicationInfo instrApp;</span><br><span class="line">        try &#123;</span><br><span class="line">            instrApp = getPackageManager().getApplicationInfo(ii.packageName, 0,</span><br><span class="line">                    UserHandle.myUserId());</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            instrApp = null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (instrApp == null) &#123;</span><br><span class="line">            instrApp = new ApplicationInfo();</span><br><span class="line">        &#125;</span><br><span class="line">        ii.copyTo(instrApp);</span><br><span class="line">        instrApp.initForUser(UserHandle.myUserId());</span><br><span class="line">        final LoadedApk pi = getPackageInfo(instrApp, data.compatInfo,</span><br><span class="line">                appContext.getClassLoader(), false, true, false);</span><br><span class="line">        final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);</span><br><span class="line">        //注释1 获取mInstrumentation</span><br><span class="line">        try &#123;</span><br><span class="line">            final ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">            mInstrumentation = (Instrumentation)</span><br><span class="line">                cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate instrumentation &quot;</span><br><span class="line">                + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // If the app is being launched for full backup or restore, bring it up in</span><br><span class="line">        // a restricted environment with the base application class.</span><br><span class="line">        app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line"></span><br><span class="line">        // Propagate autofill compat state</span><br><span class="line">        app.setAutofillCompatibilityEnabled(data.autofillCompatibilityEnabled);</span><br><span class="line"></span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        // don&apos;t bring up providers in restricted mode; they may depend on the</span><br><span class="line">        // app&apos;s custom Application class</span><br><span class="line">        if (!data.restrictedBackupMode) &#123;</span><br><span class="line">            if (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">                installContentProviders(app, data.providers);</span><br><span class="line">                // For process that contains content providers, we want to</span><br><span class="line">                // ensure that the JIT is enabled &quot;at some point&quot;.</span><br><span class="line">                mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do this after providers, since instrumentation tests generally start their</span><br><span class="line">        // test thread at this point, and we don&apos;t want that racing.</span><br><span class="line">        try &#123;</span><br><span class="line">            mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Exception thrown in onCreate() of &quot;</span><br><span class="line">                + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                  &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                  + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // If the app targets &lt; O-MR1, or doesn&apos;t change the thread policy</span><br><span class="line">        // during startup, clobber the policy to maintain behavior of b/36951662</span><br><span class="line">        if (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1</span><br><span class="line">                || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> mInstrumentation.callApplicationOnCreate(app);多么熟悉的味道，看吧，最终调用这里，不多说，里面就是application里的oncreate方法了。大家是不是想问，嗯application里的oncreate 方法是走了，那么Activity里的在哪里走，咱们回过头看看attachApplicationLocked这个方法，其实为了方便大家理解重点，后面的方法没贴哈哈，我把后面的重要方法补上你就知道了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line">    private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">            int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">                关键代码</span><br><span class="line">                else if (app.instr != null) &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                        app.instr.mClass,</span><br><span class="line">                        profilerInfo, app.instr.mArguments,</span><br><span class="line">                        app.instr.mWatcher,</span><br><span class="line">                        app.instr.mUiAutomationConnection, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers, null, profilerInfo,</span><br><span class="line">                        null, null, null, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125;</span><br><span class="line">          if (normalMode) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                    didSomething = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>mStackSupervisor.attachApplicationLocked(app)这个是重点，ActivityStackSupervisor 是不是很熟悉咱们在看看  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line">    final String processName = app.processName;</span><br><span class="line">    boolean didSomething = false;</span><br><span class="line">    for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123;</span><br><span class="line">        final ActivityDisplay display = mActivityDisplays.valueAt(displayNdx);</span><br><span class="line">        for (int stackNdx = display.getChildCount() - 1; stackNdx &gt;= 0; --stackNdx) &#123;</span><br><span class="line">            final ActivityStack stack = display.getChildAt(stackNdx);</span><br><span class="line">            if (!isFocusedStack(stack)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.getAllRunningVisibleActivitiesLocked(mTmpActivityList);</span><br><span class="line">            final ActivityRecord top = stack.topRunningActivityLocked();</span><br><span class="line">            final int size = mTmpActivityList.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                final ActivityRecord activity = mTmpActivityList.get(i);</span><br><span class="line">                if (activity.app == null &amp;&amp; app.uid == activity.info.applicationInfo.uid</span><br><span class="line">                        &amp;&amp; processName.equals(activity.processName)) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        if (realStartActivityLocked(activity, app,</span><br><span class="line">                                top == activity /* andResume */, true /* checkConfig */)) &#123;</span><br><span class="line">                            didSomething = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;Exception in new application when starting activity &quot;</span><br><span class="line">                                + top.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">                        throw e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!didSomething) &#123;</span><br><span class="line">        ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);</span><br><span class="line">    &#125;</span><br><span class="line">    return didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>realStartActivityLocked()就是这个方法 ,是不是很熟悉，接下来就走之前已有进程的Activity的启动流程了，这里就不重复说了。  </p>
<h2 id="到此，整个APP如何启动的就已经讲完了，太多了，那里有不足的地方还请大家多多包涵"><a href="#到此，整个APP如何启动的就已经讲完了，太多了，那里有不足的地方还请大家多多包涵" class="headerlink" title="到此，整个APP如何启动的就已经讲完了，太多了，那里有不足的地方还请大家多多包涵"></a><strong>到此，整个APP如何启动的就已经讲完了，太多了，那里有不足的地方还请大家多多包涵</strong></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/30/9-0系统启动流程源码分析“/" data-id="cjv3l06fw0003dslat7i35ie7" class="article-share-link">Share</a>
      
      
        <a href="/2019/04/30/9-0系统启动流程源码分析“/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2019/04/30/9-0系统启动流程源码分析“/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/23/hello-world/" class="article-date">
  <time datetime="2019-04-23T03:24:55.269Z" itemprop="datePublished">2019-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/23/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/23/hello-world/" data-id="cjv3l06dp0000dslagncmhxwy" class="article-share-link">Share</a>
      
      
        <a href="/2019/04/23/hello-world/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2019/04/23/hello-world/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/30/LayoutInflate加载详解/">LayoutInflate加载详解</a>
          </li>
        
          <li>
            <a href="/2019/04/30/Android-View加载流程分析/">Android View加载流程分析</a>
          </li>
        
          <li>
            <a href="/2019/04/30/9-0系统启动流程源码分析“/">Android 9.0系统Activity启动流程分析</a>
          </li>
        
          <li>
            <a href="/2019/04/23/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 pengqiming<br>
      Powered by <a href="https://pqmpqm123.github.io/" target="_blank">PQM</a>
    </div>
  </div>
  <div>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277361153'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s96.cnzz.com/z_stat.php%3Fid%3D1277361153%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
        return GUEST_INFO.indexOf(item) > -1
    });
    var notify = 'false' == true;
    var verify = 'false' == true;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "QI2RXf5tr8YR663tiS2jo5ux-gzGzoHsz",
        appKey: "BmGifKBVH0zFPkjejdlW3bEe",
        placeholder: "聊一聊",
        pageSize:'10',
        avatar:'mm',
        lang:'zh-cn'
    });
</script>

  </div>
</body>
</html>